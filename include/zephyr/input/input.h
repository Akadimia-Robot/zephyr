/*
 * Copyright 2023 Google LLC
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#ifndef ZEPHYR_INCLUDE_INPUT_H_
#define ZEPHYR_INCLUDE_INPUT_H_

/**
 * @brief Input Interface
 * @defgroup input_interface Input Interface
 * @ingroup io_interfaces
 * @{
 */

#include <stdint.h>
#include <zephyr/device.h>
#include <zephyr/dt-bindings/input/input-event-codes.h>
#include <zephyr/kernel.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Input event structure.
 *
 * This structure represents a single input event, for example a key or button
 * press for a single button, or an absolute or relative coordinate for a
 * single axis.
 */
struct input_event {
	/** Device generating the event or NULL. */
	const struct device *dev;
	/** Event type, one of INPUT_EV_*. */
	uint16_t type;
	/** Event code, one of INPUT_{KEY,BTN,ABS,REL,...)_*. */
	uint16_t code;
	/** Event value. */
	int32_t value;
};

/**
 * @brief Report a new input event.
 *
 * This causes all the listeners for the specified device to be triggered,
 * either synchronously or through the input thread if utilized.
 *
 * @param dev Device generating the event or NULL.
 * @param type Event type, one of INPUT_EV_*.
 * @param code Event code, one of INPUT_{KEY,BTN,ABS,REL,...)_*.
 * @param value Event value.
 * @param sync Set the synchronization bit for the event.
 * @param timeout Timeout for reporting the event, ignored if
 *                `CONFIG_INPUT_THREAD=n`.
 * @return 0 if the message has been processed, a negative error code if
 *         `CONFIG_INPUT_THREAD=y` and the message failed to be enqueued.
 */
int input_report(const struct device *dev,
		 uint16_t type, uint16_t code, int32_t value, bool sync,
		 k_timeout_t timeout);

/**
 * @brief Report a new INPUT_EV_KEY input event.
 *
 * See `input_report` for more details.  Note that value is converted to either
 * 0 or 1.
 */
static inline int input_report_key(const struct device *dev,
				   uint16_t code, int32_t value, bool sync,
				   k_timeout_t timeout)
{
	return input_report(dev, INPUT_EV_KEY, code, !!value, sync, timeout);
}

/**
 * @brief Report a new INPUT_EV_REL input event.
 *
 * See `input_report` for more details.
 */
static inline int input_report_rel(const struct device *dev,
				   uint16_t code, int32_t value, bool sync,
				   k_timeout_t timeout)
{
	return input_report(dev, INPUT_EV_REL, code, value, sync, timeout);
}

/**
 * @brief Report a new INPUT_EV_ABS input event.
 *
 * See `input_report` for more details.
 */
static inline int input_report_abs(const struct device *dev,
				   uint16_t code, int32_t value, bool sync,
				   k_timeout_t timeout)
{
	return input_report(dev, INPUT_EV_ABS, code, value, sync, timeout);
}

/**
 * @brief Returns true if the input queue is empty.
 *
 * This can be used to batch input event processing until the whole queue has
 * been emptied. Always returns true if `CONFIG_INPUT_THREAD=n`.
 */
bool input_queue_empty(void);

/**
 * @brief Input listener callback structure.
 */
struct input_listener {
	/** `struct device` pointer or NULL. */
	const struct device *dev;
	/** The callback function. */
	void (*callback)(struct input_event *evt, bool sync);
};

/**
 * @brief Register a callback structure for input events.
 *
 * The `_dev` field can be used to only invoke callback for events generated by
 * a specific device. Setting dev to NULL causes callback to be invoked for
 * every event.
 *
 * @param _dev `struct device` pointer or NULL.
 * @param _callback The callback function.
 */
#define INPUT_LISTENER_CB_DEFINE(_dev, _callback) \
	static const STRUCT_SECTION_ITERABLE(input_listener, \
					     _input_listener__##_callback) = { \
		.dev = _dev, \
		.callback = _callback, \
	};

#ifdef __cplusplus
}
#endif

/** @} */

#endif /* ZEPHYR_INCLUDE_INPUT_H_ */
