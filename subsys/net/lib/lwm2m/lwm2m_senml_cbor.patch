From 13d32a65f64dfc483b1513237a6e9736b130c5f2 Mon Sep 17 00:00:00 2001
From: Pascal Brogle <pascal.brogle@husqvarnagroup.com>
Date: Thu, 24 Nov 2022 14:47:14 +0100
Subject: [PATCH] net: lwm2m: regenerate cbor code using zcbor

Signed-off-by: Pascal Brogle <pascal.brogle@husqvarnagroup.com>
---
 .../net/lib/lwm2m/lwm2m_senml_cbor_decode.c   | 88 ++++++++++---------
 .../net/lib/lwm2m/lwm2m_senml_cbor_decode.h   |  5 +-
 .../net/lib/lwm2m/lwm2m_senml_cbor_encode.c   | 51 +++++++----
 .../net/lib/lwm2m/lwm2m_senml_cbor_encode.h   |  5 +-
 subsys/net/lib/lwm2m/lwm2m_senml_cbor_types.h | 13 ++-
 5 files changed, 96 insertions(+), 66 deletions(-)

diff --git a/subsys/net/lib/lwm2m/lwm2m_senml_cbor_decode.c b/subsys/net/lib/lwm2m/lwm2m_senml_cbor_decode.c
index b1cabba34b..559a52cabb 100644
--- a/subsys/net/lib/lwm2m/lwm2m_senml_cbor_decode.c
+++ b/subsys/net/lib/lwm2m/lwm2m_senml_cbor_decode.c
@@ -9,13 +9,13 @@
  * Generated with a --default-max-qty of 99
  */
 
+#include "lwm2m_senml_cbor_decode.h"
+#include "zcbor_decode.h"
 
 #include <stdbool.h>
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
-#include "zcbor_decode.h"
-#include "lwm2m_senml_cbor_decode.h"
 
 static bool decode_repeated_record_bn(zcbor_state_t *state, struct record_bn *result);
 static bool decode_repeated_record_bt(zcbor_state_t *state, struct record_bt *result);
@@ -46,11 +46,11 @@ static bool decode_repeated_record_bt(zcbor_state_t *state, struct record_bt *re
 {
 	zcbor_print("%s\r\n", __func__);
 
-	bool tmp_result = ((((zcbor_int32_expect(state, (-3)))) &&
-			    (zcbor_int64_decode(state, (&(*result)._record_bt))) &&
-			    ((((*result)._record_bt >= INT64_MIN) &&
-			      ((*result)._record_bt <= INT64_MAX)) ||
-			     (zcbor_error(state, ZCBOR_ERR_WRONG_RANGE), false))));
+	bool tmp_result =
+		((((zcbor_int32_expect(state, (-3)))) &&
+		  (zcbor_int64_decode(state, (&(*result)._record_bt))) &&
+		  ((((*result)._record_bt >= INT64_MIN) && ((*result)._record_bt <= INT64_MAX)) ||
+		   (zcbor_error(state, ZCBOR_ERR_WRONG_RANGE), false))));
 
 	if (!tmp_result)
 		zcbor_trace();
@@ -75,11 +75,11 @@ static bool decode_repeated_record_t(zcbor_state_t *state, struct record_t *resu
 {
 	zcbor_print("%s\r\n", __func__);
 
-	bool tmp_result = ((((zcbor_uint32_expect(state, (6)))) &&
-			    (zcbor_int64_decode(state, (&(*result)._record_t))) &&
-			    ((((*result)._record_t >= INT64_MIN) &&
-			      ((*result)._record_t <= INT64_MAX)) ||
-			     (zcbor_error(state, ZCBOR_ERR_WRONG_RANGE), false))));
+	bool tmp_result =
+		((((zcbor_uint32_expect(state, (6)))) &&
+		  (zcbor_int64_decode(state, (&(*result)._record_t))) &&
+		  ((((*result)._record_t >= INT64_MIN) && ((*result)._record_t <= INT64_MAX)) ||
+		   (zcbor_error(state, ZCBOR_ERR_WRONG_RANGE), false))));
 
 	if (!tmp_result)
 		zcbor_trace();
@@ -90,28 +90,36 @@ static bool decode_repeated_record_t(zcbor_state_t *state, struct record_t *resu
 static bool decode_repeated_record_union(zcbor_state_t *state, struct record_union_ *result)
 {
 	zcbor_print("%s\r\n", __func__);
+	struct zcbor_string tmp_str;
 	bool int_res;
 
-	bool tmp_result = (((zcbor_union_start_code(state) &&
-			     (int_res = (((((zcbor_uint32_expect_union(state, (2)))) &&
-					   (zcbor_int64_decode(state, (&(*result)._union_vi))) &&
-					   ((((*result)._union_vi >= INT64_MIN) &&
-					     ((*result)._union_vi <= INT64_MAX)) ||
-					    (zcbor_error(state, ZCBOR_ERR_WRONG_RANGE), false))) &&
-					  (((*result)._record_union_choice = _union_vi), true)) ||
-					 ((((zcbor_uint32_expect_union(state, (2)))) &&
-					   (zcbor_float_decode(state, (&(*result)._union_vf)))) &&
-					  (((*result)._record_union_choice = _union_vf), true)) ||
-					 ((((zcbor_uint32_expect_union(state, (3)))) &&
-					   (zcbor_tstr_decode(state, (&(*result)._union_vs)))) &&
-					  (((*result)._record_union_choice = _union_vs), true)) ||
-					 ((((zcbor_uint32_expect_union(state, (4)))) &&
-					   (zcbor_bool_decode(state, (&(*result)._union_vb)))) &&
-					  (((*result)._record_union_choice = _union_vb), true)) ||
-					 ((((zcbor_uint32_expect_union(state, (8)))) &&
-					   (zcbor_bstr_decode(state, (&(*result)._union_vd)))) &&
-					  (((*result)._record_union_choice = _union_vd), true))),
-			      zcbor_union_end_code(state), int_res))));
+	bool tmp_result =
+		(((zcbor_union_start_code(state) &&
+		   (int_res = (((((zcbor_uint32_expect_union(state, (2)))) &&
+				 (zcbor_int64_decode(state, (&(*result)._union_vi))) &&
+				 ((((*result)._union_vi >= INT64_MIN) &&
+				   ((*result)._union_vi <= INT64_MAX)) ||
+				  (zcbor_error(state, ZCBOR_ERR_WRONG_RANGE), false))) &&
+				(((*result)._record_union_choice = _union_vi), true)) ||
+			       ((((zcbor_uint32_expect_union(state, (2)))) &&
+				 (zcbor_float_decode(state, (&(*result)._union_vf)))) &&
+				(((*result)._record_union_choice = _union_vf), true)) ||
+			       ((((zcbor_uint32_expect_union(state, (3)))) &&
+				 (zcbor_tstr_decode(state, (&(*result)._union_vs)))) &&
+				(((*result)._record_union_choice = _union_vs), true)) ||
+			       ((((zcbor_uint32_expect_union(state, (4)))) &&
+				 (zcbor_bool_decode(state, (&(*result)._union_vb)))) &&
+				(((*result)._record_union_choice = _union_vb), true)) ||
+			       ((((zcbor_uint32_expect_union(state, (8)))) &&
+				 (zcbor_bstr_decode(state, (&(*result)._union_vd)))) &&
+				(((*result)._record_union_choice = _union_vd), true)) ||
+			       (zcbor_union_elem_code(state) &&
+				((((zcbor_tstr_expect(
+					  state, ((tmp_str.value = (uint8_t *)"vlo",
+						   tmp_str.len = sizeof("vlo") - 1, &tmp_str))))) &&
+				  (zcbor_tstr_decode(state, (&(*result)._union_vlo)))) &&
+				 (((*result)._record_union_choice = _union_vlo), true)))),
+		    zcbor_union_end_code(state), int_res))));
 
 	if (!tmp_result)
 		zcbor_trace();
@@ -212,14 +220,14 @@ static bool decode_lwm2m_senml(zcbor_state_t *state, struct lwm2m_senml *result)
 {
 	zcbor_print("%s\r\n", __func__);
 
-	bool tmp_result = ((
-		(zcbor_list_start_decode(state) &&
-		 ((zcbor_multi_decode(1, ZCBOR_ARRAY_SIZE(result->_lwm2m_senml__record),
-				      &(*result)._lwm2m_senml__record_count,
-				      (zcbor_decoder_t *)decode_record, state,
-				      (&(*result)._lwm2m_senml__record), sizeof(struct record))) ||
-		  (zcbor_list_map_end_force_decode(state), false)) &&
-		 zcbor_list_end_decode(state))));
+	bool tmp_result =
+		(((zcbor_list_start_decode(state) &&
+		   ((zcbor_multi_decode(
+			    1, ZCBOR_ARRAY_SIZE(result->_lwm2m_senml__record),
+			    &(*result)._lwm2m_senml__record_count, (zcbor_decoder_t *)decode_record,
+			    state, (&(*result)._lwm2m_senml__record), sizeof(struct record))) ||
+		    (zcbor_list_map_end_force_decode(state), false)) &&
+		   zcbor_list_end_decode(state))));
 
 	if (!tmp_result)
 		zcbor_trace();
diff --git a/subsys/net/lib/lwm2m/lwm2m_senml_cbor_decode.h b/subsys/net/lib/lwm2m/lwm2m_senml_cbor_decode.h
index cf425e9006..1b425988d0 100644
--- a/subsys/net/lib/lwm2m/lwm2m_senml_cbor_decode.h
+++ b/subsys/net/lib/lwm2m/lwm2m_senml_cbor_decode.h
@@ -12,12 +12,13 @@
 #ifndef LWM2M_SENML_CBOR_DECODE_H__
 #define LWM2M_SENML_CBOR_DECODE_H__
 
+#include "lwm2m_senml_cbor_types.h"
+#include "zcbor_decode.h"
+
 #include <stdbool.h>
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
-#include "zcbor_decode.h"
-#include "lwm2m_senml_cbor_types.h"
 
 int cbor_decode_lwm2m_senml(const uint8_t *payload, size_t payload_len, struct lwm2m_senml *result,
 			    size_t *payload_len_out);
diff --git a/subsys/net/lib/lwm2m/lwm2m_senml_cbor_encode.c b/subsys/net/lib/lwm2m/lwm2m_senml_cbor_encode.c
index 3c0c190981..54008c1391 100644
--- a/subsys/net/lib/lwm2m/lwm2m_senml_cbor_encode.c
+++ b/subsys/net/lib/lwm2m/lwm2m_senml_cbor_encode.c
@@ -9,13 +9,14 @@
  * Generated with a --default-max-qty of 99
  */
 
+#include "lwm2m_senml_cbor_encode.h"
+#include "lwm2m_senml_cbor_types.h"
+#include "zcbor_encode.h"
+
 #include <stdbool.h>
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
-#include "zcbor_encode.h"
-#include "lwm2m_senml_cbor_encode.h"
-#include "lwm2m_senml_cbor_types.h"
 
 static bool encode_repeated_record_bn(zcbor_state_t *state, const struct record_bn *input);
 static bool encode_repeated_record_bt(zcbor_state_t *state, const struct record_bt *input);
@@ -46,11 +47,11 @@ static bool encode_repeated_record_bt(zcbor_state_t *state, const struct record_
 {
 	zcbor_print("%s\r\n", __func__);
 
-	bool tmp_result = ((((zcbor_int32_put(state, (-3)))) &&
-			    ((((*input)._record_bt >= INT64_MIN) &&
-			      ((*input)._record_bt <= INT64_MAX)) ||
-			     (zcbor_error(state, ZCBOR_ERR_WRONG_RANGE), false)) &&
-			    (zcbor_int64_encode(state, (&(*input)._record_bt)))));
+	bool tmp_result =
+		((((zcbor_int32_put(state, (-3)))) &&
+		  ((((*input)._record_bt >= INT64_MIN) && ((*input)._record_bt <= INT64_MAX)) ||
+		   (zcbor_error(state, ZCBOR_ERR_WRONG_RANGE), false)) &&
+		  (zcbor_int64_encode(state, (&(*input)._record_bt)))));
 
 	if (!tmp_result)
 		zcbor_trace();
@@ -75,11 +76,11 @@ static bool encode_repeated_record_t(zcbor_state_t *state, const struct record_t
 {
 	zcbor_print("%s\r\n", __func__);
 
-	bool tmp_result = ((((zcbor_uint32_put(state, (6)))) &&
-			    ((((*input)._record_t >= INT64_MIN) &&
-			      ((*input)._record_t <= INT64_MAX)) ||
-			     (zcbor_error(state, ZCBOR_ERR_WRONG_RANGE), false)) &&
-			    (zcbor_int64_encode(state, (&(*input)._record_t)))));
+	bool tmp_result =
+		((((zcbor_uint32_put(state, (6)))) &&
+		  ((((*input)._record_t >= INT64_MIN) && ((*input)._record_t <= INT64_MAX)) ||
+		   (zcbor_error(state, ZCBOR_ERR_WRONG_RANGE), false)) &&
+		  (zcbor_int64_encode(state, (&(*input)._record_t)))));
 
 	if (!tmp_result)
 		zcbor_trace();
@@ -90,6 +91,7 @@ static bool encode_repeated_record_t(zcbor_state_t *state, const struct record_t
 static bool encode_repeated_record_union(zcbor_state_t *state, const struct record_union_ *input)
 {
 	zcbor_print("%s\r\n", __func__);
+	struct zcbor_string tmp_str;
 
 	bool tmp_result = (((
 		((*input)._record_union_choice == _union_vi)
@@ -113,9 +115,22 @@ static bool encode_repeated_record_union(zcbor_state_t *state, const struct reco
 								    ? (((zcbor_uint32_put(state,
 											  (8)))) &&
 								       (zcbor_bstr_encode(
-									state,
-									(&(*input)._union_vd))))
-								    : false)))))));
+									       state,
+									       (&(*input)._union_vd))))
+								    : (((*input)._record_union_choice ==
+									_union_vlo)
+									       ? (((zcbor_tstr_encode(
+											  state,
+											  ((tmp_str.value =
+												    (uint8_t *)"vlo",
+											    tmp_str.len =
+												    sizeof("vlo") -
+												    1,
+											    &tmp_str))))) &&
+										  (zcbor_tstr_encode(
+											  state,
+											  (&(*input)._union_vlo))))
+									       : false))))))));
 
 	if (!tmp_result)
 		zcbor_trace();
@@ -145,8 +160,8 @@ static bool encode_value(zcbor_state_t *state, const struct value_ *input)
 								   (&(*input)._value_float))))
 							 : (((*input)._value_choice == _value_bool)
 								    ? ((zcbor_bool_encode(
-									state,
-									(&(*input)._value_bool))))
+									      state,
+									      (&(*input)._value_bool))))
 								    : false)))))));
 
 	if (!tmp_result)
diff --git a/subsys/net/lib/lwm2m/lwm2m_senml_cbor_encode.h b/subsys/net/lib/lwm2m/lwm2m_senml_cbor_encode.h
index 1a3591ba62..049e57dc7b 100644
--- a/subsys/net/lib/lwm2m/lwm2m_senml_cbor_encode.h
+++ b/subsys/net/lib/lwm2m/lwm2m_senml_cbor_encode.h
@@ -12,12 +12,13 @@
 #ifndef LWM2M_SENML_CBOR_ENCODE_H__
 #define LWM2M_SENML_CBOR_ENCODE_H__
 
+#include "lwm2m_senml_cbor_types.h"
+#include "zcbor_encode.h"
+
 #include <stdbool.h>
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
-#include "zcbor_encode.h"
-#include "lwm2m_senml_cbor_types.h"
 
 int cbor_encode_lwm2m_senml(uint8_t *payload, size_t payload_len, const struct lwm2m_senml *input,
 			    size_t *payload_len_out);
diff --git a/subsys/net/lib/lwm2m/lwm2m_senml_cbor_types.h b/subsys/net/lib/lwm2m/lwm2m_senml_cbor_types.h
index f7cf2c1baa..a0196f3a52 100644
--- a/subsys/net/lib/lwm2m/lwm2m_senml_cbor_types.h
+++ b/subsys/net/lib/lwm2m/lwm2m_senml_cbor_types.h
@@ -4,6 +4,7 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 /*
+ *
  * Generated using zcbor version 0.6.0
  * https://github.com/zephyrproject-rtos/zcbor
  * Generated with a --default-max-qty of 99
@@ -12,18 +13,18 @@
 #ifndef LWM2M_SENML_CBOR_TYPES_H__
 #define LWM2M_SENML_CBOR_TYPES_H__
 
+#include "zcbor_common.h"
+
 #include <stdbool.h>
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
-#include "zcbor_common.h"
-
 
 enum lwm2m_senml_cbor_key {
 	lwm2m_senml_cbor_key_bn = -2,
 	lwm2m_senml_cbor_key_bt = -3,
-	lwm2m_senml_cbor_key_n  = 0,
-	lwm2m_senml_cbor_key_t  = 6,
+	lwm2m_senml_cbor_key_n = 0,
+	lwm2m_senml_cbor_key_t = 6,
 	lwm2m_senml_cbor_key_vi = 2,
 	lwm2m_senml_cbor_key_vf = 2,
 	lwm2m_senml_cbor_key_vs = 3,
@@ -73,6 +74,9 @@ struct record_union_ {
 		struct {
 			struct zcbor_string _union_vd;
 		};
+		struct {
+			struct zcbor_string _union_vlo;
+		};
 	};
 	enum {
 		_union_vi,
@@ -80,6 +84,7 @@ struct record_union_ {
 		_union_vs,
 		_union_vb,
 		_union_vd,
+		_union_vlo,
 	} _record_union_choice;
 };
 
-- 
2.25.1

