#!/usr/bin/env python3
#
# Copyright (c) 2017 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
"""
Script to verify that symbol addresses have not shifted between builds
"""

import sys
import argparse
import os
from elftools.elf.elffile import ELFFile
from elftools.elf.sections import SymbolTableSection

# Each entry here needs a comment explaining why it's OK to ignore it
shift_whitelist = [
        # For KPTI x86 generates a second set of page tables right after
        # the kernel's page table. The sizes aren't known when the prebuilt
        # kernel is built.
        "z_x86_user_pdpt",

        # The true size of functions generated by gperf isn't known.
        # We do enforce that CONFIG_KOBJECT_TEXT_AREA is enforced;
        # _kobject_text_area_end does not move.
        "_kobject_text_area_used",

        # The specific memory addresses and sizes of these functions
        # generated by gperf move between builds isn't known.
        # _kobject_text_area_end does not move.
        "z_object_gperf_find",
        "z_object_gperf_wordlist_foreach",

        # The size of all the generated pages tables isn't known at build
        # time.
        "__mmu_tables_end",

        # Various generated data structures of unknown size end up at the
        # very end of the data section. It's expected that the bounds of
        # the data section will change between builds.
        "__data_size",
        "__data_ram_end",
        "__data_num_words",
        "_image_ram_end",
        "_end",

        # The rom section is allowed to shift in size if and only if
        # this is a XIP system, since RAM is somewhere else in memory.
        # On non-XIP, this isn't allowed as the RAM region would just be
        # immediately after ROM, but we'll get failures with
        # _image_ram_start shifting.
        "_image_rom_end",
        "_image_rodata_end",
        "_flash_used",

        # All members of the kobject_data output section are free to move.
        "_thread_idx_map",

        # On XIP systems, various data items are copied out of ROM (flash)
        # addresses intp RAM. This is in the binary immediately after
        # the rodata section. However, the rodata section is not of fixed
        # size between builds as gperf defined data stuctures end up here.
        # This shifts the LMA of regions that need to be copied into RAM
        # at boot. The VMAs do not shift.
        "_app_smem_rom_start",
        "__data_rom_start",
        "_ramfunc_rom_start",

        # fixme why
        "wordlist"
        ]

def get_symbols(filename):
    with open(filename, "rb") as fp:
        kernel = ELFFile(fp)

        for section in kernel.iter_sections():
            if isinstance(section, SymbolTableSection):
                ret = {}
                for sym in section.iter_symbols():
                    # Not a value we care about
                    sym.entry.st_name = 0
                    sym.entry.st_shndx = 0
                    ret[sym.name] = sym.entry
                return ret

        raise LookupError("Could not find symbol table")

def parse_args():
    global args

    parser = argparse.ArgumentParser(
            description=__doc__,
            formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument("-k", "--kernel", required=True,
            help="Final zephyr kernel image")
    parser.add_argument("-p", "--prebuilt-kernel", required=True,
            help="Prebuilt zephyr kernel image")
    parser.add_argument("-v", "--verbose", action="store_true",
            help="Print extra debugging information")

    args = parser.parse_args()
    if "VERBOSE" in os.environ:
        args.verbose = 1

def main():
    parse_args()

    final_kernel = get_symbols(args.kernel)
    prebuilt_kernel = get_symbols(args.prebuilt_kernel)
    success = True

    if args.verbose:
        for name, entry in final_kernel.items():
            if name not in prebuilt_kernel:
                print(name, "only in final kernel")
                print(entry, "\n")
        for name, entry in prebuilt_kernel.items():
            if name not in final_kernel:
                print(name, "only in prebuilt kernel")
                print(entry, "\n")

    for name, final_entry in final_kernel.items():
        #print(name)
        if (not name or
                name not in prebuilt_kernel or
                name in shift_whitelist or
                name.startswith("priv_stack_") or # can we fix?
                name.startswith("$")):
            # Ignore symbols that aren't in both kernels
            continue

        prebuilt_entry = prebuilt_kernel[name]

        if final_entry != prebuilt_entry:
            print(name, "\n\t", prebuilt_entry, "\n\t", final_entry, "\n")
            success = False

    if not success:
        sys.exit(1)

if __name__ == "__main__":
    main()
