macro(toolchain_bintools_usermode)

  if(CONFIG_ARM AND CONFIG_USERSPACE)
    set(GEN_PRIV_STACKS           $ENV{ZEPHYR_BASE}/scripts/gen_priv_stacks.py)
    set(PROCESS_PRIV_STACKS_GPERF $ENV{ZEPHYR_BASE}/scripts/process_gperf.py)

    set(PRIV_STACKS                    priv_stacks_hash.gperf)
    set(PRIV_STACKS_OUTPUT_SRC_PRE     priv_stacks_hash_preprocessed.c)
    set(PRIV_STACKS_OUTPUT_SRC         priv_stacks_hash.c)
    set(PRIV_STACKS_OUTPUT_OBJ         priv_stacks_hash.c.obj)
    set(PRIV_STACKS_OUTPUT_OBJ_RENAMED priv_stacks_hash_renamed.o)

    # Essentially what we are doing here is extracting some information
    # out of the nearly finished elf file, generating the source code
    # for a hash table based on that information, and then compiling and
    # linking the hash table back into a now even more nearly finished
    # elf file.

    # Use the script GEN_PRIV_STACKS to scan the kernel binary's
    # (zephyr_prebuilt) DWARF information to produce a table of kernel
    # objects (PRIV_STACKS) which we will then pass to gperf
    add_custom_command(
      OUTPUT ${PRIV_STACKS}
      COMMAND
      ${PYTHON_EXECUTABLE}
      ${GEN_PRIV_STACKS}
      --kernel $<TARGET_FILE:priv_stacks_prebuilt>
      --output ${PRIV_STACKS}
      $<$<BOOL:${CMAKE_VERBOSE_MAKEFILE}>:--verbose>
      DEPENDS priv_stacks_prebuilt
      WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )
    add_custom_target(priv_stacks DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${PRIV_STACKS})

    # Use gperf to generate C code (PRIV_STACKS_OUTPUT_SRC_PRE) which implements a
    # perfect hashtable based on PRIV_STACKS
    add_custom_command(
      OUTPUT ${PRIV_STACKS_OUTPUT_SRC_PRE}
      COMMAND
      ${GPERF} -C
      --output-file ${PRIV_STACKS_OUTPUT_SRC_PRE}
      ${PRIV_STACKS}
      DEPENDS priv_stacks ${PRIV_STACKS}
      WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )
    add_custom_target(priv_stacks_output_src_pre DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${PRIV_STACKS_OUTPUT_SRC_PRE})

    # For our purposes the code/data generated by gperf is not optimal.
    #
    # The script PROCESS_GPERF creates a new c file OUTPUT_SRC based on
    # OUTPUT_SRC_PRE to greatly reduce the amount of code/data generated
    # since we know we are always working with pointer values
    add_custom_command(
      OUTPUT ${PRIV_STACKS_OUTPUT_SRC}
      COMMAND
      ${PYTHON_EXECUTABLE}
      ${PROCESS_PRIV_STACKS_GPERF}
      -i ${PRIV_STACKS_OUTPUT_SRC_PRE}
      -o ${PRIV_STACKS_OUTPUT_SRC}
      -p "struct _k_priv_stack_map"
      $<$<BOOL:${CMAKE_VERBOSE_MAKEFILE}>:--verbose>
      DEPENDS priv_stacks_output_src_pre ${PRIV_STACKS_OUTPUT_SRC_PRE}
      WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )
    add_custom_target(priv_stacks_output_src DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${PRIV_STACKS_OUTPUT_SRC})

    # We need precise control of where generated text/data ends up in the final
    # kernel image. Disable function/data sections and use objcopy to move
    # generated data into special section names
    add_library(priv_stacks_output_lib STATIC
      ${CMAKE_CURRENT_BINARY_DIR}/${PRIV_STACKS_OUTPUT_SRC}
    )

    target_link_libraries(priv_stacks_output_lib zephyr_interface)

    # Turn off -ffunction-sections, etc.
    # NB: Using a library instead of target_compile_options(priv_stacks_output_lib
    # [...]) because a library's options have precedence
    add_library(priv_stacks_output_lib_interface INTERFACE)
    target_compile_options(priv_stacks_output_lib_interface INTERFACE
      -fno-function-sections
      -fno-data-sections
    )
    target_link_libraries(priv_stacks_output_lib priv_stacks_output_lib_interface)

    set(PRIV_STACKS_OUTPUT_OBJ_PATH ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/priv_stacks_output_lib.dir/${PRIV_STACKS_OUTPUT_OBJ})

    add_custom_command(
      OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${PRIV_STACKS_OUTPUT_OBJ_RENAMED}
      COMMAND
      ${CMAKE_OBJCOPY}
      --rename-section   .bss=.priv_stacks.noinit
      --rename-section   .data=.priv_stacks.data
      --rename-section   .text=.priv_stacks.text
      --rename-section .rodata=.priv_stacks.rodata
      ${PRIV_STACKS_OUTPUT_OBJ_PATH}
      ${PRIV_STACKS_OUTPUT_OBJ_RENAMED}
      DEPENDS priv_stacks_output_lib
      WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )
    add_custom_target(priv_stacks_output_obj_renamed DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${PRIV_STACKS_OUTPUT_OBJ_RENAMED})

    add_library(priv_stacks_output_obj_renamed_lib STATIC IMPORTED GLOBAL)
    set_property(
      TARGET priv_stacks_output_obj_renamed_lib
      PROPERTY
      IMPORTED_LOCATION ${CMAKE_CURRENT_BINARY_DIR}/${PRIV_STACKS_OUTPUT_OBJ_RENAMED}
    )
    add_dependencies(
      priv_stacks_output_obj_renamed_lib
      priv_stacks_output_obj_renamed
    )

    set_property(GLOBAL APPEND PROPERTY GENERATED_KERNEL_OBJECT_FILES priv_stacks_output_obj_renamed_lib)
  endif()


  if(CONFIG_USERSPACE)
    set(GEN_KOBJ_LIST ${ZEPHYR_BASE}/scripts/gen_kobject_list.py)
    set(PROCESS_GPERF ${ZEPHYR_BASE}/scripts/process_gperf.py)

    set(OBJ_LIST           kobject_hash.gperf)
    set(OUTPUT_SRC_PRE     kobject_hash_preprocessed.c)
    set(OUTPUT_SRC         kobject_hash.c)
    set(OUTPUT_OBJ         kobject_hash.c.obj)
    set(OUTPUT_OBJ_RENAMED kobject_hash_renamed.o)

    # Essentially what we are doing here is extracting some information
    # out of the nearly finished elf file, generating the source code
    # for a hash table based on that information, and then compiling and
    # linking the hash table back into a now even more nearly finished
    # elf file.

    # Use the script GEN_KOBJ_LIST to scan the kernel binary's
    # (zephyr_prebuilt) DWARF information to produce a table of kernel
    # objects (OBJ_LIST) which we will then pass to gperf
    add_custom_command(
      OUTPUT ${OBJ_LIST}
      COMMAND
      ${PYTHON_EXECUTABLE}
      ${GEN_KOBJ_LIST}
      --kernel $<TARGET_FILE:zephyr_prebuilt>
      --gperf-output ${OBJ_LIST}
      $<$<BOOL:${CMAKE_VERBOSE_MAKEFILE}>:--verbose>
      DEPENDS zephyr_prebuilt
      WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )
    add_custom_target(obj_list DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${OBJ_LIST})

    # Use gperf to generate C code (OUTPUT_SRC_PRE) which implements a
    # perfect hashtable based on OBJ_LIST
    add_custom_command(
      OUTPUT ${OUTPUT_SRC_PRE}
      COMMAND
      ${GPERF}
      --output-file ${OUTPUT_SRC_PRE}
      ${OBJ_LIST}
      DEPENDS obj_list ${OBJ_LIST}
      WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )
    add_custom_target(output_src_pre DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_SRC_PRE})

    # For our purposes the code/data generated by gperf is not optimal.
    #
    # The script PROCESS_GPERF creates a new c file OUTPUT_SRC based on
    # OUTPUT_SRC_PRE to greatly reduce the amount of code/data generated
    # since we know we are always working with pointer values
    add_custom_command(
      OUTPUT ${OUTPUT_SRC}
      COMMAND
      ${PYTHON_EXECUTABLE}
      ${PROCESS_GPERF}
      -i ${OUTPUT_SRC_PRE}
      -o ${OUTPUT_SRC}
      -p "struct _k_object"
      $<$<BOOL:${CMAKE_VERBOSE_MAKEFILE}>:--verbose>
      DEPENDS output_src_pre ${OUTPUT_SRC_PRE}
      WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )
    add_custom_target(output_src DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_SRC})

    # We need precise control of where generated text/data ends up in the final
    # kernel image. Disable function/data sections and use objcopy to move
    # generated data into special section names
    add_library(output_lib STATIC
      ${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_SRC}
    )

    # always compile kobject_hash.c at optimization -Os
    set_source_files_properties(${OUTPUT_SRC} PROPERTIES COMPILE_FLAGS -Os)
    target_link_libraries(output_lib zephyr_interface)

    # Turn off -ffunction-sections, etc.
    # NB: Using a library instead of target_compile_options(output_lib
    # [...]) because a library's options have precedence
    add_library(output_lib_interface INTERFACE)
    target_compile_options(output_lib_interface INTERFACE
      -fno-function-sections
      -fno-data-sections
    )
    target_link_libraries(output_lib output_lib_interface)

    set(OUTPUT_OBJ_PATH ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/output_lib.dir/${OUTPUT_OBJ})

    add_custom_command(
      OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_OBJ_RENAMED}
      COMMAND
      ${CMAKE_OBJCOPY}
      --rename-section   .data=.kobject_data.data
      --rename-section   .text=.kobject_data.text
      --rename-section .rodata=.kobject_data.rodata
      ${OUTPUT_OBJ_PATH}
      ${OUTPUT_OBJ_RENAMED}
      DEPENDS output_lib
      WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )
    add_custom_target(output_obj_renamed DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_OBJ_RENAMED})

    add_library(output_obj_renamed_lib STATIC IMPORTED GLOBAL)
    set_property(
      TARGET output_obj_renamed_lib
      PROPERTY
      IMPORTED_LOCATION ${CMAKE_CURRENT_BINARY_DIR}/${OUTPUT_OBJ_RENAMED}
    )
    add_dependencies(
      output_obj_renamed_lib
      output_obj_renamed
    )

    set_property(GLOBAL APPEND PROPERTY GENERATED_KERNEL_OBJECT_FILES output_obj_renamed_lib)
  endif()


  # TODO: Only configure_file if CONFIG_USERSPACE; currently always done
  configure_file(
    $ENV{ZEPHYR_BASE}/include/arch/arm/cortex_m/scripts/app_data_alignment.ld
    ${PROJECT_BINARY_DIR}/include/generated/app_data_alignment.ld
  )

  # TODO: Only configure_file if CONFIG_USERSPACE; currently always done
  configure_file(
    $ENV{ZEPHYR_BASE}/include/arch/arm/cortex_m/scripts/app_smem.ld
    ${PROJECT_BINARY_DIR}/include/generated/app_smem.ld
  )

  if(CONFIG_CPU_HAS_MPU AND CONFIG_USERSPACE)

    if(CONFIG_MPU_REQUIRES_POWER_OF_TWO_ALIGNMENT AND CONFIG_APP_SHARED_MEM)
      set(APP_SMEM_LD "${PROJECT_BINARY_DIR}/include/generated/app_smem.ld")
      set(OBJ_FILE_DIR "${PROJECT_BINARY_DIR}/../")

      add_custom_target(
        ${APP_SMEM_DEP} ALL
        DEPENDS app
        kernel
      )

      add_custom_command(
        TARGET ${APP_SMEM_DEP}
        COMMAND ${PYTHON_EXECUTABLE}
        ${ZEPHYR_BASE}/scripts/gen_app_partitions.py
        -d ${OBJ_FILE_DIR}
        -o ${APP_SMEM_LD}
        $<$<BOOL:${CMAKE_VERBOSE_MAKEFILE}>:--verbose>
        WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/
        COMMENT "Generating power of 2 aligned app_smem linker section"
      )
    endif()


    if(CONFIG_MPU_REQUIRES_POWER_OF_TWO_ALIGNMENT AND CONFIG_APPLICATION_MEMORY)

      toolchain_cc_preprocess_linker_pass(linker_app_sizing)

      add_custom_target(
        linker_app_sizing_script
        DEPENDS
        linker_app_sizing.cmd
        offsets_h
        ${APP_SMEM_DEP}
      )

      set_property(TARGET
        linker_app_sizing_script
        PROPERTY INCLUDE_DIRECTORIES
        ${ZEPHYR_INCLUDE_DIRS}
      )

      # For systems with MPUs, the size of the application data section must
      # be determined so that MPU alignment requirements can be met.
      # Create a app_sizing_prebuilt target so we can do this before the
      # other ELF files are built
      set(GEN_APP_ALIGN $ENV{ZEPHYR_BASE}/scripts/gen_alignment_script.py)
      add_executable(       app_sizing_prebuilt misc/empty_file.c)
      target_link_libraries(app_sizing_prebuilt -T ${PROJECT_BINARY_DIR}/linker_app_sizing.cmd ${zephyr_lnk})
      set_property(TARGET   app_sizing_prebuilt PROPERTY LINK_DEPENDS ${PROJECT_BINARY_DIR}/linker_app_sizing.cmd)
      add_dependencies(     app_sizing_prebuilt linker_app_sizing_script offsets )

      add_custom_command(
        TARGET app_sizing_prebuilt
        POST_BUILD
        COMMAND ${PYTHON_EXECUTABLE} ${GEN_APP_ALIGN}
        --output ./include/generated/app_data_alignment.ld
        --kernel $<TARGET_FILE:app_sizing_prebuilt>
        VERBATIM
        WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/
      )
    endif()

    if(CONFIG_ARM)
      toolchain_cc_preprocess_linker_pass(linker_priv_stacks)

      add_custom_target(
        linker_priv_stacks_script
        DEPENDS
        ${ALIGN_SIZING_DEP} ${APP_SMEM_DEP}
        linker_priv_stacks.cmd
        offsets_h
      )

      set_property(TARGET
        linker_priv_stacks_script
        PROPERTY INCLUDE_DIRECTORIES
        ${ZEPHYR_INCLUDE_DIRS}
      )

      set(PRIV_STACK_LIB priv_stacks_output_obj_renamed_lib)
      add_executable(       priv_stacks_prebuilt misc/empty_file.c)
      target_link_libraries(priv_stacks_prebuilt -T ${PROJECT_BINARY_DIR}/linker_priv_stacks.cmd ${zephyr_lnk})
      set_property(TARGET   priv_stacks_prebuilt PROPERTY LINK_DEPENDS ${PROJECT_BINARY_DIR}/linker_priv_stacks.cmd)
      add_dependencies(     priv_stacks_prebuilt ${ALIGN_SIZING_DEP} linker_priv_stacks_script offsets)
    endif()

  endif()

endmacro()
