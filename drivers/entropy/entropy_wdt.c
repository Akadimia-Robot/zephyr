/*
 * Copyright (c) 2018 Intel Corporation
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/* This driver works by racing two timers: (1) a watchdog timer, and
 * (2) a system timer.  Both are set to expire in intervals that are
 * very close together.
 *
 * Watchdog timers are not precise -- they're often implemented using
 * RC timer circuits, which are cheap but subject to fluctuations due
 * to external factors such as temperature and supply voltage.
 *
 * System timers, on the other hand, are often controlled by a crystal
 * or a closed loop oscillator such as a PLL, and are much more
 * precise.
 *
 * By comparing the CPU cycles at the moment the watchdog timer expires
 * with the number of CPU cycles at the time the system timer expires,
 * a bit of entropy is generated and accumulated into a sample byte.
 *
 * Every sample that is generated by the race is then stored in a pool.
 * The race is stopped when this pool is full, to reduce power
 * consumption due to increased wake ups to service the interrupts; it
 * starts again as soon as bytes are consumed from the pool.
 *
 * Since only the least 8 significant bits of the difference is
 * considered when accumulating into the sample byte, it's important to
 * keep the CPU cycles difference as close as possible.  Each time a
 * sample contains 8 bytes, the system timer is restarted in an effort
 * to reduce the drift between the two timers.
 *
 * While this effectively solves the issue of not having enough entropy
 * on devices without a hardware random number generator, it also makes
 * use of the watchdog timer that the application developer might want
 * to consider using.
 */

#include <zephyr.h>

#include <device.h>
#include <watchdog.h>

#include <errno.h>

/* 2^16 cycles for the watchdog is 2.048ms; if changing one value, the
 * other one needs to be changed so it's as close as possible.
 *
 * Keep in mind that this generates close to 1bit of entropy every time
 * these timers expire, so to generate a full byte, it's going to take
 * about 16.384ms.  To generate enough entropy to initialize a PRNG
 * such as rand32_xoroshiro128.c, this will take about 65.536ms.
 */
#define WATCHDOG_TIMEOUT WDT_2_16_CYCLES
#define TIMER_TIMEOUT K_MSEC(2)

struct entropy_wdt_data {
	struct device *wdt;
	struct k_timer timer;

	/* Struct protected by `ewd_entropy_sem`, defined below. */
	struct {
		u8_t buffer[16];
		u8_t first;
		u8_t last;
		u8_t population;

		bool need_restart;
	} entropy;

	/* Struct protected by `ewd_sample_sem`, defined below. */
	struct {
		u32_t cycle_wdt_timer;

		u8_t current_byte;
		u8_t bits;

		bool has_wdt_sample;
	} sample;
};

static struct entropy_wdt_data ewd;
static K_SEM_DEFINE(ewd_entropy_sem, 1, 1);
static K_SEM_DEFINE(ewd_sample_sem, 1, 1);

static void entropy_wdt_stop_timers(void)
{
	wdt_disable(ewd.wdt);
	k_timer_stop(&ewd.timer);
}

static void entropy_wdt_start_timers(void)
{
	wdt_enable(ewd.wdt);
	k_timer_start(&ewd.timer, TIMER_TIMEOUT, TIMER_TIMEOUT);
}

static bool entropy_wdt_put_byte(void)
{
	bool stopped_timer;
	int ret;

	ret = k_sem_take(&ewd_entropy_sem, K_FOREVER);
	if (ret < 0) {
		return false;
	}

	ewd.entropy.buffer[ewd.entropy.last] = ewd.sample.current_byte;
	ewd.entropy.last = (ewd.entropy.last + 1) & 15;
	ewd.entropy.population = (entropy.population + 1) & 15;

	if (!ewd.entropy.population) {
		/* The entropy pool is full.  Disable the timers
		 * temporarily to reduce power consumption.
		 *
		 * FIXME: consider not turning them off, but slowing
		 * them.
		 */
		entropy_wdt_stop_timers();

		ewd.entropy.need_restart = true;
		stopped_timer = true;
	} else {
		stopped_timer = false;
	}

	k_sem_give(&ewd_entropy_sem);

	return stopped_timer;
}

static int entropy_wdt_get_bytes(u8_t *byte, u16_t len)
{
	int ret;

	ret = k_sem_take(&ewd_entropy_sem, K_FOREVER);
	if (ret < 0) {
		return ret;
	}

	if (ewd.entropy.population < len || !ewd.entropy.population) {
		ret = -ENOBUFS;
	} else {
		while (len--) {
			*byte = ewd.entropy.buffer[ewd.entropy.first];
			byte++;

			ewd.entropy.first = (ewd.entropy.first + 1) & 15;
			ewd.entropy.population--;
		}

		if (ewd.entropy.need_restart) {
			ewd.entropy.need_restart = false;
			ewd_entropy_start_timers();
		}
	}

	k_sem_give(&ewd_entropy_sem);

	return ret;
}

static void entropy_wdt_watchdog_expired(struct device *device)
{
	/* Wait up to TIMER_TIMEOUT/2 to obtain this semaphore.  If
	 * this waited for K_FOREVER seconds, the watchdog would expire
	 * again and the system would reboot (watchdog is set to
	 * WDT_MODE_INTERRUPT_RESET since it's the only mode that will
	 * call an ISR).
	 */
	if (!k_sem_take(&ewd_sample_sem, TIMER_TIMEOUT / 2)) {
		ewd.sample.cycle_wdt_timer = k_cycle_get_32();

		/* Since the semaphore might not be taken, mark that we
		 * actually have a sample waiting, so that the system
		 * timer callback do not try to calculate the difference
		 * with a stale cycle_wdt_timer value.
		 */
		ewd.sample.has_wdt_sample = true;

		k_sem_give(&ewd_sample_sem);
	}

	wdt_reload(device);
}

static inline u8_t rotl(const u8_t x, int k)
{
	return (x << k) | (x >> (8 - k));
}

static void entropy_wdt_timer_expired(struct k_timer *timer)
{
	if (k_sem_take(&ewd_sample_sem, K_FOREVER) < 0) {
		return;
	}

	if (!ewd.sample.has_wdt_sample) {
		goto out;
	}

	ewd.sample.has_wdt_sample = false;

	ewd.sample.current_byte = rotl(ewd->sample.current_byte, 1);
	ewd.sample.current_byte ^= (u8_t)(ewd.sample.cycle_wdt_timer -
					  k_cycle_get_32());

	ewd.bits = (ewd.bits + 1) & 7;
	if (!ewd.bits) {
		bool stopped = entropy_wdt_put_byte();

		/* Do not start the timer again if it has been
		 * stopped because the entropy pool got full.
		 */
		if (!stopped) {
			k_timer_start(&ewd.timer, TIMER_TIMEOUT,
				      TIMER_TIMEOUT);
		}
	}

out:
	k_sem_give(&ewd_sample_sem);
}

static int entropy_wdt_get_entropy(struct device *device, u8_t *buf, u16_t len)
{
	ARG_UNUSED(device);

	return entropy_wdt_get_bytes(buf, len);
}

static int entropy_wdt_init(struct device *device)
{
	static const struct wdt_config config = {
		.timeout = WATCHDOG_TIMEOUT,
		.mode = WDT_MODE_INTERRUPT_RESET,
		.interrupt_fn = entropy_wdt_watchdog_expired,
	};
	int ret;

	ewd.wdt = device_get_binding(CONFIG_WDT_NAME);
	if (!ewd.wdt) {
		return -ENODEV;
	}

	ret = wdt_set_config(ewd.wdt, &config);
	if (ret < 0) {
		return ret;
	}

	k_timer_init(&ewd.timer, entropy_wdt_timer_expired, NULL);

	/* Start the race. */
	entropy_wdt_start_timers();

	return 0;
}

static struct entropy_driver_api entropy_wdt_api_funcs = {
	.get_entropy = entropy_wdt_get_entropy,
};

DEVICE_AND_API_INIT(entropy_wdt, CONFIG_ENTROPY_NAME,
		    entropy_wdt_init, NULL, NULL,
		    PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &entropy_wdt_api_funcs);
