#!/usr/bin/env python3
#
# Copyright (c) 2022 CSIRO
#
# SPDX-License-Identifier: Apache-2.0
"""Generate a C source version of the ordered init entries.
"""

import sys
import argparse
import os
import pickle
from collections import OrderedDict

import elf_parser

# This is needed to load edt.pickle files.
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..',
                                'dts', 'python-devicetree', 'src'))
from devicetree import edtlib  # pylint: disable=unused-import

def parse_args():
    global args

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument("-k", "--kernel", required=True,
                        help="Input zephyr ELF binary")
    parser.add_argument("-o", "--output-source", required=True,
                        help="Output source file")
    parser.add_argument("-g", "--output-graphviz",
                        help="Output file for graphviz dependency graph")
    parser.add_argument("-z", "--zephyr-base",
                        help="Path to current Zephyr base. If this argument \
                        is not provided the environment will be checked for \
                        the ZEPHYR_BASE environment variable.")

    args = parser.parse_args()

    ZEPHYR_BASE = args.zephyr_base or os.getenv("ZEPHYR_BASE")

    if ZEPHYR_BASE is None:
        sys.exit("-z / --zephyr-base not provided. Please provide "
                 "--zephyr-base or set ZEPHYR_BASE in environment")

    sys.path.insert(0, os.path.join(ZEPHYR_BASE, "scripts/dts"))

def c_entry_write(entry):
    d = "&{:s}".format(entry.dev.sym.name) if entry.dev else "NULL"
    return "\t{{.init = {:}, .dev = {:}}},\n".format(entry.init.name, d)

def main():
    parse_args()

    edtser = os.path.join(os.path.split(args.kernel)[0], "edt.pickle")
    with open(edtser, 'rb') as f:
        edt = pickle.load(f)

    parsed_elf = elf_parser.ZephyrElf(args.kernel, edt)

    # Generated sorted list of init entries from original elf
    entries = OrderedDict([(l.name, []) for l in elf_parser.InitEntry.InitLevel])
    manual_devices = []
    init_functions = set()

    prev = None
    for addr in sorted(parsed_elf.init_entries.keys()):
        e = parsed_elf.init_entries[addr]
        entries[e.level.name].append(e)
        init_functions.add(e.init.name)

        # Device not part of devicetree, we need to declare it
        if e.dev and not e.dev.edt_node:
            manual_devices.append(e.dev.sym.name)

        # Validate layout assumptions
        if prev:
            assert(prev.level <= e.level)
        prev = e

    with open(args.output_source, "w") as fp:
        fp.write('/*\n')
        fp.write(' * Generated by gen_init_arrays.py\n')
        fp.write(' */\n')
        fp.write('#include <zephyr/device.h>\n')
        fp.write('\n')

        # Declare init functions
        fp.write('/* Init functions */\n')
        for f in init_functions:
            fp.write('int {:s}(const struct device *dev);\n'.format(f))
        fp.write('\n')

        # Forward declare manually instantiated devices
        if len(manual_devices) > 0:
            fp.write('/* Manually instantiated devices */\n')
        for d in manual_devices:
            fp.write('extern const struct device {:s};\n'.format(d))
        fp.write('\n')

        # Create init arrays
        for l in elf_parser.InitEntry.InitLevel:
            fp.write('/* Init Level: {:s} */\n'.format(l.name))

            s = '__attribute__((__section__(".z_init_{:s}")))'.format(l.name)
            fp.write('const struct init_entry init_entries_{:s}[] {:s} = {{\n'.format(l.name, s))
            for e in entries[l.name]:
                fp.write(c_entry_write(e))
            fp.write('};\n\n')

if __name__ == "__main__":
    main()
