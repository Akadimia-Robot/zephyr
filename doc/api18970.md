# Draft material to review in support of [#18970][]

[//]: # (cmark-gfm -e table -e footnotes doc/api18970.md > /tmp/api18970.html)

[#18970]: https://github.com/zephyrproject-rtos/zephyr/issues/18970

Note: See the Background] section below for technical concepts necessary
to understand the definitions.

## Definitions

### rescheduling (function)

A function is rescheduling when a path through it reaches a reschedule
point.

#### Commentary

Note that whether a rescheduling function will cause a context switch
depends on the priority of the current and first ready threads at the
reschedule point and whether the reschedule point enabled unconditional
preemption.

Unless interrupts are disabled any function may force a cooperative
thread to be context-switched if the interrupt causes a meta-irq thread
to become ready.

If interrupts are disabled a zero-latency interrupt can still be
invoked, which may cause a meta-irq thread to become ready.

The term *rescheduling* applies only to functions that (directly or
indirectly) invoke operations that (may) encounter a reschedule point.
I.e. any resulting context switch is a result of invoking the function,
rather than some external behavior.

### sleeps (thread)

A thread sleeps if it is the current thread and it invokes an operation
that directly causes itself to transition to an active state other than
*Running*.

#### Commentary

When the current thread sleeps the reschedule point will context-switch
unless the current thread remains *Ready* and is at the head of the
ready queue.

A rescheduling function like `k_mutex_unlock()` does not directly cause
a thread to sleep.  That its reschedule point may result in a context
switch is due to the interaction between the priority of the current
thread and that of the head of the ready queue.

### blocking (function)

A function is blocking if it can cause its invoking thread to sleep.

#### Commentary

**TODO** It would be best to eliminate this term and define things in
terms of "does not sleep".  For now this is convenient shorthand.

### no-wait (function)

A function is no-wait if it is blocking.

A function is conditionally no-wait if it is blocking but a parameter
can force the function to take a path that will not reach a blocking
reschedule point.

### isr-callable (function)

A function is isr-callable if and only if it is (conditionally) no-wait.

#### Commentary

META: This is intentionally not `isr-safe` because experience suggests
people may confuse it with "interrupt-safe", which is completely
different.

### thread-safe

A function is thread-safe if its behavior is correct when invocations
from multiple threads are active simultaneously.

#### Commentary

See *rescheduling*.

Note that it may be impossible to guarantee thread safety when using
Zephyr preemptible or meta-irq threads.

### reentrant

A function is reentrant if its behavior is correct when it is invoked by
(indirect) recursion from the same thread.

### interrupt-safe

A function is interrupt-safe if its behavior is not affected by
concurrent access to shared data from interrupts.

#### Commentary

Most public API will satisfy this condition; some private API may not.

We need to be able to say succinctly "Unless otherwise specified all API
functions are interrupt-safe" and expect people to know what that means.
A specific example would be the GPIO API.  Because GPIO write functions
may be invoked from ISRs read-modify-write code like:

```
u32_t out = gpio->OUT;
gpio->OUT ^= (out & ~mask) | (value & mask);
```

*must* be wrapped in a spin-lock to be interrupt-safe.  Many current
implementations do not satisfy this requirement.

On the other hand internal functions may be written to assume they are
called with interrupts disabled, or a specific lock held.

**TODO** standard marking?

### atomic

An operation is atomic if the steps it makes internally cannot be
affected by nor visible to interleaving executions, such as from
interrupts or thread pre-emption.

#### Commentary

An operation that is atomic is by definition interrupt-safe.

An operation that is atomic is by definition thread-safe.

### synchronous (function) (vs asynchronous)

A function is synchronous if it will not return until the operation it
initiates has completed.

#### Commentary

The term "blocking" may be used for a synchronous function in cases
where synchrony is produced by causing the invoking thread to sleep.  It
is possible to have a synchronous non-sleeping function; an example is
`k_busy_wait()`.

### asynchronous (function) (vs synchronous)

A function is asynchronous if it may return before the operation it
initiates has completed.  An asynchronous function will generally
provide a mechanism by which operation completion is reported, e.g. a
callback or event.

#### Commentary

Note that asynchronous is orthogonal to context-switching.  Some API may
provide completion information through a callback, but may suspend while
waiting for the resource necessary to initiate the operation; an example
is `spi_transceive_async()`.

### queued (proposed, TBD)

A function is queued if it is asynchronous and allows multiple
operations to be outstanding at any time.

#### Commentary

This concept is proposed due to operations like `spi_transceive_async()`
which returns its result through a signal but will suspend if the device
is already processing an asynchronous operation.

A related capability that is non-suspendable could be implemented
through through passing a chainable persisted state object to hold the
operation parameters in a persisted state object that can be added to an
internal queue for processing when the required resource is available.
Such a theoretical API might be described as *queued*.

Since this term specifies the mechanism by which a non-suspending
asynchronous function supports multiple incomplete operations, rather
than just that behavior, it should probably be avoided.

## Other Rules

## To Do

- [ ] Consider a standard marking for private functions that must be
      invoked with an held or interrupts disabled, such as a suffix
      `_locked`.
- [ ] Define the terminology related to execution context

## Background

This section summarizes existing and relevant Zephyr concepts,
introducing clarifications where necessary.  See also the Zephyr
[glossary][].

[glossary]: https://docs.zephyrproject.org/latest/glossary.html

### Thread Terminology

Thread behavior in Zephyr is documented in three locations which in
aggregate are not entirely consistent:
* [Threads](https://docs.zephyrproject.org/latest/reference/kernel/threads/index.html)
* [Scheduling](https://docs.zephyrproject.org/latest/reference/kernel/scheduling/index.html)
* The [Interrupt](https://docs.zephyrproject.org/latest/guides/porting/arch.html#interrupt-and-exception-handling)
  and [Context Switching](https://docs.zephyrproject.org/latest/guides/porting/arch.html#thread-context-switching)
  sections of the [Architecture Porting Guide](https://docs.zephyrproject.org/latest/guides/porting/arch.html)

Zephyr defines [six thread
states](https://docs.zephyrproject.org/latest/reference/kernel/threads/index.html#thread-states)
of which four are active:

* **Ready** when there is nothing that prevents the thread from becoming
  active as the current thread, but it is not the current thread.
* **Running** when the thread is active as the current thread (on a
  processor).
* **Waiting** when the thread is on a queue waiting for an event to occur
  that will transition it to *Ready*.
* **Suspended** when the thread is inactive and must be transitioned to
  *Ready* explicitly (e.g. via `k_thread_resume()`.

A thread is made **unready** if it transitions to *Suspended*,
*Waiting*, or *Terminated*, whether the transition is a result of an
action taken by the thread (e.g. `k_sleep()`) or an action initiated
externally (e.g. `k_thread_abort()`).

Zephyr defines [two mechanisms for selecting the running
thread](https://docs.zephyrproject.org/latest/reference/kernel/scheduling/index.html#scheduling):
* In **cooperative** scheduling a thread transitions from *Running* only
  when it invokes `k_yield()`, or it (or something outside the current
  thread) invokes an operation that makes the thread unready.
* In **preemptive** scheduling a thread may be involuntarily
  transitioned from *Running* to *Ready* based on a change in
  conditions, such as elapsed runtime or transition of a higher-priority
  thread to a *Ready* state.

A **reschedule point** is any point where the kernel calls the internal
logic that selects the next thread to run.  Reschedule points include:
* Return from an ISR to thread execution;
* Invoking `k_yield()`;
* Invoking any action that makes the current thread unready;
* Most (all?) actions that cause a thread to become *Ready*, including
  completion of a timeslice when a preemptible thread is current.

A **context switch** occurs at a reschedule point when the next thread
selected to run is different from the most recent current thread.

Invoking a function that reaches a reschedule point does not guarantee a
context switch, it simply provides an opportunity.  Whether a context
switch occurs depends on the priority of the current thread and the
thread at the head of the ready queue.

Zephyr defines [two core classes of
threads](https://docs.zephyrproject.org/latest/reference/kernel/threads/index.html#thread-priorities)
with one [extension](https://docs.zephyrproject.org/latest/reference/kernel/scheduling/index.html#meta-irq-priorities):

* **preemptible** threads remain the current thread until
  * a cooperative thread becomes *Ready*; or
  * a higher-priority preemptible thread becomes *Ready*; or
  * the thread invokes an operation that explicitly causes it to become
    unready.
* **cooperative** threads remain the current thread until something
  causes it to become unready or it invokes `k_yield()`.
* **meta-irq** threads are cooperative threads with a special property
  that they *do* pre-empt cooperative threads with lower priorites,
  *and* are not excluded when using a scheduler lock.

The class of the thread is uniquely determined by its priority: All
cooperative threads have a priority higher than any preemptible thread,
and meta-IRQ threads have a priority higher than any other cooperative thread.

Most Zephyr threads are cooperative, and some code may take advantage of
this by assuming the behavior of reschedule points reached during an
operation will be guided by the invoking thread being cooperative.

Given this, define the following terms:

* A thread **suspends** when it voluntarily invokes a function that
  causes it to transition from *Running* to *Suspended*.
  (`k_sleep()` is such a function.)
* A thread **waits** when it voluntarily invokes a function that causes
  it to transition from *Running* to *Waiting*.  (`k_poll()` is such a
  function.)
* A thread **yields** when it voluntarily invokes a function that causes
  it to transition from *Running* to *Ready*.  (`k_yield()` is such a
  function.)
* A thread **sleeps** when it voluntarily invokes a function that causes
  it to suspend, wait, or yield.
* A thread is **preempted** when it is *Running* but a reschedule point
  (involuntarily) transitions it to *Ready*.

A **context switch** occurs when the reschedule point selects a thread
other than the current thread to execute next.

For API behavior we are primarily interested in whether invoking a
function can directly cause a thread invoking it to sleep.

#### Digresssions and random notes

*Suspended* could be perceived as a variant of *Waiting* where the
releasing event is an invocation of `k_thread_resume()`, possibly
performed by the callback of a timeout associated with the thread.

For operations that cause a transition from *Running* to *Waiting* a
timeout value `K_NO_WAIT` indicates that the operation should fail
rather than change the thread state.  The failure is indicated with an
operation-specific error code such as `-EAGAIN`, `-EBUSY`, `-ENOMEM`,
and `-ENOMSG`.

* `z_pend_curr` transitions the current thread to **Waiting**;
* `k_yield` transitions the current thread to **Ready** and moves it to
  the end of the ready queue.  It also explicitly overrides the default
  preservation of cooperative threads as the current thread.
* `k_sleep` invokes `k_yield()` if timeout is zero, otherwise suspends
  the thread until the timeout.

An operation cannot be invoked from an ISR if:
* It transitions the current thread to *Suspended* (per assert in
  `z_tick_sleep()`)
* It transitions the current thread to *Waiting* (per documentation of
  e.g. `k_sem_take()`)
* It transitions the current thread to *Ready* (per assert in
  `k_yield()`)

Generalizing this, and consistent with the informal answer to issue
21341, an operation cannot be invoked when invoked from a non-thread
context (interrupt or pre-kernel) if it could cause its invoking thread
to sleep, because without in invoking thread it cannot implement the
required behavior.

Kernel API assessed using terminology below, plus "cooperative-safe"

API                  | rescheduling | blocking | no-wait
-------------------- | ------------ | -------- | ------------
`k_yield()`          | yes          | yes      | no
`k_sleep()`          | yes          | yes      | no
`k_busy_wait()`      | no           | no       | yes
`k_mutex_unlock()`   | yes          | no       | yes
`k_mutex_lock()`     | yes          | yes      | conditional
`k_sem_give()`       | yes          | no       | yes
`k_sem_take()`       | yes          | yes      | conditional
`k_wakeup()`         | yes          | no       | yes
`k_thread_suspend()` | yes          | if !curr | iff !block
`k_thread_resume()`  | yes          | no       | yes

### Context Terminology

There are three execution contexts in which code might be executed,
shown in the following table.

Context    | Stack     | Kernel Services | Indicator
---------- | --------- | --------------- | ----------
pre-kernel | interrupt | some available  | `k_is_pre_kernel()`
thread     | thread    | available       | `!(k_is_pre_kernel() \|\| k_is_in_isr())`
interrupt  | interrupt | some available  | `k_is_in_isr()`

Kernel services are available in pre-kernel and interrupt context only
when their behavior does not allow the caller to sleep.  Services for
which state is not yet initialized are also excluded (this mostly
applies to pre-kernel context).

**TODO** fill in gaps above where content below is not addressed

This section is intended to describe the privilege and processor context
variations in which a thread can run.  It should provide or reference
definitions of terms like this:

* Kernel [initialization
  level](https://docs.zephyrproject.org/latest/reference/drivers/index.html#initialization-levels)
* User-space versus kernel (system call)
* Normal ("thread"?) versus interrupt (invoked from an Interrupt Service
  Routine)

For API behavior we are interested in whether a particular function
**may**, **must**, or **must not** be invoked from a specific context.

### Function vs Operation

tl;dr: A function *returns* while an operation *completes*.

A **function** is an addressible sequence of actions to which control is
transferred by **invoking** the function with various parameters, and
from which control is transferred back to the point where it was invoked
when the function **returns**.

A function may succeed or fail.  In many cases failure is indicated by a
negative integer return value while success is indicated by a
non-negative integer return value, but specific functions may use other
conventions.

An **operation** is behavior, which is generally initiated by invoking a
function.  An operation can also succeed or fail.  An operation
**completes** when the success or failure of the operation has been
determined and made available through whatever mechanism was specified
through the initiating function.

For APIs we are particularly interested in the relationship between the
function and its associated operation.  Some potential relationships
include:
* The function succeeds if and only if its associated operation
  completes with success. (This is usually expected of *synchronous*
  functions.)
* If the function fails then its associated operation has not been
  initiated.  If the function succeeds then its associated operation has
  been initiated.  The success or failure of the operation is not
  otherwise coupled to success or failure of its initiating function.
  (This is usually expected of *asynchronous* functions.)
