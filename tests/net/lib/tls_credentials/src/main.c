/*
 * Copyright (c) 2018 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/ztest.h>

#include "tls_internal.h"

#define TEST_DNAME "CN=US"

static const char test_ca_cert[] = "Test CA certificate";
static const char test_server_cert[] = "Test server certificate";
static const char test_server_key[] = "Test server key";

static char pk_buf_a[200];
static char pk_buf_b[200];
static char csr_buf[400];

enum credential_features {
	CF_NONE,
	CF_KEYGEN,
	CF_CSR,
	CF_KEYGEN_CSR
};

#if defined(CONFIG_TLS_CREDENTIAL_CSR)
static char dname_buf[100];
#endif /* defined(CONFIG_TLS_CREDENTIAL_CSR) */

#define UNUSED_TAG	CONFIG_TLS_MAX_CREDENTIALS_NUMBER
#define INVALID_TAG	(CONFIG_TLS_MAX_CREDENTIALS_NUMBER + 1)
#define COMMON_TAG	(CONFIG_TLS_MAX_CREDENTIALS_NUMBER - 1)
#define CSR_TAG_A	(CONFIG_TLS_MAX_CREDENTIALS_NUMBER - 2)
#define CSR_TAG_B	(CONFIG_TLS_MAX_CREDENTIALS_NUMBER - 3)

/* Generated with `openssl ecparam -name prime256v1 -genkey`
 * This is the raw ASN.1 data extracted from the PEM output generated by that command.
 */
static char test_key[] = {
	0x30, 0x77, 0x02, 0x01, 0x01, 0x04, 0x20, 0xaa,
	0x30, 0x9b, 0xd0, 0xc9, 0x6c, 0x73, 0xee, 0x2f,
	0x53, 0xd7, 0x80, 0x5e, 0x6b, 0x08, 0xe4, 0x83,
	0x92, 0xa5, 0x7c, 0x95, 0x43, 0x90, 0x80, 0x73,
	0xdf, 0x32, 0x1d, 0xd1, 0xbd, 0x18, 0xea, 0xa0,
	0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d,
	0x03, 0x01, 0x07, 0xa1, 0x44, 0x03, 0x42, 0x00,
	0x04, 0xf8, 0x4b, 0xd9, 0x1f, 0x4b, 0xc5, 0x01,
	0x51, 0x73, 0x0f, 0xbe, 0x18, 0x51, 0x65, 0x53,
	0x15, 0x84, 0x79, 0x11, 0x8d, 0xdf, 0x1b, 0xc8,
	0xe5, 0xaa, 0xcd, 0xb1, 0x2b, 0x43, 0x53, 0x2f,
	0xa3, 0x72, 0x9c, 0x58, 0x02, 0xfe, 0xa0, 0x33,
	0x8e, 0xb1, 0xbb, 0x7b, 0x01, 0x87, 0xb6, 0x5f,
	0xf1, 0xcf, 0x47, 0x91, 0x4f, 0xd6, 0xdc, 0x4c,
	0xd6, 0x3c, 0x44, 0xc0, 0x3d, 0x83, 0x6d, 0x35,
	0xb6
};

/**
 * @brief Clear a credential (if it exists) from a slot and then verify that the slot no
 *        longer has it.
 */
static void clear_cred(unsigned int slot, enum tls_credential_keygen_type type)
{
	char cred[64];
	size_t cred_len = sizeof(cred);
	int ret;

	/* Attempt to delete the credential, ignoring errors */
	(void)tls_credential_delete(slot, type);

	/* Verify that the credential was deleted (or perhaps never existed) */
	ret = tls_credential_get(slot, type, cred, &cred_len);

	zassert_equal(ret, -ENOENT, "Failed to delete credential %d of type %d.", slot, type);
}

/* Checks memory region for all bytes of a specific value. */
static bool alleq(char *buf, size_t len, char val) {
	for (int i = 0; i < len; i++) {
		if (buf[i] != val) {
			return false;
		}
	}
	return true;
}


/**
 * @brief Test test_credential_add function
 *
 * This test verifies the credential add operation.
 */
static void test_credential_add(void)
{
	int ret, i;

	for (i = 0; i < CONFIG_TLS_MAX_CREDENTIALS_NUMBER - 2; i++) {
		ret = tls_credential_add(i, TLS_CREDENTIAL_CA_CERTIFICATE,
					 test_ca_cert, sizeof(test_ca_cert));
		zassert_equal(ret, 0, "Failed to add credential %d %d", i);
	}

	/* Function should allow to add credentials of different types
	 * with the same tag
	 */
	ret = tls_credential_add(COMMON_TAG, TLS_CREDENTIAL_SERVER_CERTIFICATE,
				 test_server_cert, sizeof(test_server_cert));
	zassert_equal(ret, 0, "Failed to add credential %d %d",
		      COMMON_TAG, TLS_CREDENTIAL_SERVER_CERTIFICATE);

	ret = tls_credential_add(COMMON_TAG, TLS_CREDENTIAL_PRIVATE_KEY,
				 test_server_key, sizeof(test_server_key));
	zassert_equal(ret, 0, "Failed to add credential %d %d",
		      COMMON_TAG, TLS_CREDENTIAL_PRIVATE_KEY);

	/* Try to register another credential - should not have memory for that
	 */
	ret = tls_credential_add(UNUSED_TAG, TLS_CREDENTIAL_CA_CERTIFICATE,
				 test_ca_cert, sizeof(test_ca_cert));
	zassert_equal(ret, -ENOMEM, "Should have failed with ENOMEM");

	/* Try to re-register with already registered tag and type */
	ret = tls_credential_add(COMMON_TAG, TLS_CREDENTIAL_PRIVATE_KEY,
				 test_server_key, sizeof(test_server_key));
	zassert_equal(ret, -EEXIST, "Should have failed with EEXIST");
}

/**
 * @brief Test test_credential_get function
 *
 * This test verifies the credential get operation.
 */
static void test_credential_get(void)
{
	char cred[64];
	size_t credlen;
	int ret;

	/* Read existing credential */
	(void)memset(cred, 0, sizeof(cred));
	credlen = sizeof(cred);
	ret = tls_credential_get(COMMON_TAG, TLS_CREDENTIAL_PRIVATE_KEY,
				 cred, &credlen);
	zassert_equal(ret, 0, "Failed to read credential %d %d",
		      0, TLS_CREDENTIAL_CA_CERTIFICATE);
	ret = strcmp(cred, test_server_key);
	zassert_equal(ret, 0, "Invalid credential content");
	zassert_equal(credlen, sizeof(test_server_key),
		      "Invalid credential length");

	/* Try to read non-existing credentials */
	credlen = sizeof(cred);
	ret = tls_credential_get(INVALID_TAG, TLS_CREDENTIAL_PSK,
				 cred, &credlen);
	zassert_equal(ret, -ENOENT, "Should have failed with ENOENT");

	/* Try to read with too small buffer */
	credlen = sizeof(test_server_cert) - 1;
	ret = tls_credential_get(COMMON_TAG, TLS_CREDENTIAL_SERVER_CERTIFICATE,
				 cred, &credlen);
	zassert_equal(ret, -EFBIG, "Should have failed with EFBIG");
}

/**
 * @brief Test test_credential_internal_iterate function
 *
 * This test verifies the internal function for iterating over credentials.
 */
static void test_credential_internal_iterate(void)
{
	struct tls_credential *cert, *key, *temp;

	/* Non-existing credential should return NULL */
	key = credential_next_get(INVALID_TAG, NULL);
	zassert_is_null(key, "Should have return NULL for unknown credential");

	/* Iterate over credentials with the same tag */
	cert = credential_next_get(COMMON_TAG, NULL);
	zassert_not_null(cert, "Should have find a credential");

	key = credential_next_get(COMMON_TAG, cert);
	zassert_not_null(key, "Should have find a credential");

	if (cert->type == TLS_CREDENTIAL_PRIVATE_KEY) {
		/* Function does not guarantee order of reads,
		 * so assume we could read key first
		 */
		temp = key;
		key = cert;
		cert = temp;
	}

	zassert_equal(cert->type, TLS_CREDENTIAL_SERVER_CERTIFICATE,
		      "Invalid type for cert");
	zassert_equal(cert->tag, COMMON_TAG, "Invalid tag for cert");
	zassert_equal(cert->len, sizeof(test_server_cert),
		      "Invalid cert length");
	zassert_mem_equal(cert->buf, test_server_cert, sizeof(test_server_key),
			  "Invalid cert content");

	zassert_equal(key->type, TLS_CREDENTIAL_PRIVATE_KEY,
		      "Invalid type for key");
	zassert_equal(key->tag, COMMON_TAG, "Invalid tag for key");
	zassert_equal(key->len, sizeof(test_server_key), "Invalid key length");
	zassert_mem_equal(key->buf, test_server_key, sizeof(test_server_key),
			  "Invalid key content");

	/* Iteration after getting last credential should return NULL */
	key = credential_next_get(COMMON_TAG, key);
	zassert_is_null(key, "Should have return NULL after last credential");
}

/**
 * @brief Test test_credential_delete function
 *
 * This test verifies the credential delete operation.
 */
static void test_credential_delete(void)
{
	int ret;
	char cred[64];
	size_t credlen = sizeof(cred);

	/* Should fail if when trying to remove non-existing credential. */
	ret = tls_credential_delete(INVALID_TAG, TLS_CREDENTIAL_CA_CERTIFICATE);
	zassert_equal(ret, -ENOENT, "Should have failed with ENOENT");

	/* Should remove existing credential. */
	ret = tls_credential_delete(COMMON_TAG, TLS_CREDENTIAL_PRIVATE_KEY);
	zassert_equal(ret, 0, "Failed to delete credential %d %d",
		      COMMON_TAG, TLS_CREDENTIAL_PRIVATE_KEY);

	ret = tls_credential_get(COMMON_TAG, TLS_CREDENTIAL_PRIVATE_KEY,
				 cred, &credlen);
	zassert_equal(ret, -ENOENT, "Should have failed with ENOENT");
}


#if defined(CONFIG_TLS_CREDENTIAL_CSR) || defined(CONFIG_TLS_CREDENTIAL_KEYGEN)

#include <mbedtls/pk.h>
#include <mbedtls/x509_csr.h>

#include <zephyr/random/random.h>

/* MbedTLS requires a random for blinding, so provide a (not cryptographically secure)
 * random generator for testing purposes.
 */
static int tls_rng(void *ctx, unsigned char *buf, size_t len)
{
	ARG_UNUSED(ctx);

	sys_rand_get(buf, len);

	return 0;
}

#endif /* defined(CONFIG_TLS_CREDENTIAL_CSR) || defined(CONFIG_TLS_CREDENTIAL_KEYGEN) */


#if defined(CONFIG_TLS_CREDENTIAL_KEYGEN)

/* Check a private and public key pair, ensure they match. */
static bool validate_keypair(char *priv, size_t priv_len, char *pub, size_t pub_len)
{
	int ret;
	bool result = false;
	mbedtls_pk_context pk_priv;
	mbedtls_pk_context pk_pub;

	/* Private key should be readable by MbedTLS. */
	mbedtls_pk_init(&pk_priv);
	ret = mbedtls_pk_parse_key(&pk_priv, priv, priv_len, NULL, 0, tls_rng, NULL);
	zassert_equal(ret, 0, "Private key should be readable by MbedTLS");

	/* Public key should be readable by MbedTLS. */
	mbedtls_pk_init(&pk_pub);
	ret = mbedtls_pk_parse_public_key(&pk_pub, pub, pub_len);
	zassert_equal(ret, 0, "Public key should be readable by MbedTLS");

	/* Generated private key should match CSR public key */
	result = mbedtls_pk_check_pair(&pk_pub, &pk_priv, tls_rng, NULL) == 0;

	mbedtls_pk_free(&pk_priv);
	mbedtls_pk_free(&pk_pub);

	return result;
}

#else /* defined(CONFIG_TLS_CREDENTIAL_KEYGEN) */
static bool validate_keypair(char *priv, size_t priv_len, char *pub, size_t pub_len)
{
	zassert_unreachable("Invalid call to validate_keypair. Bad test?");
	return false;
}
#endif /* defined(CONFIG_TLS_CREDENTIAL_KEYGEN) */

#if defined(CONFIG_TLS_CREDENTIAL_CSR)

/* Test that CSR works as expected, with or without keygen.
 * This indirectly covers keygen validity testing.
 */
static void test_csr(enum credential_features feat)
{
	int ret;
	size_t csr_len;
	size_t csr_len_in;
	size_t pk_len_a;
	size_t pk_len_b;
	char *csr_buf_mid = csr_buf + 150;
	mbedtls_x509_csr csr;
	mbedtls_pk_context pk;
	bool keygen = feat == CF_KEYGEN_CSR;
	enum tls_credential_keygen_type keygen_type = keygen ? TLS_CREDENTIAL_KEYGEN_DEFAULT :
							       TLS_CREDENTIAL_KEYGEN_EXISTING;

	zassert_not_equal(feat, CF_NONE, "Invalid feature-set for test_csr. Bad test?");
	zassert_not_equal(feat, CF_KEYGEN, "Invalid feature-set for test_csr. Bad test?");

	memset(pk_buf_a, 0, sizeof(pk_buf_a));

	if (!keygen) {
		ret = tls_credential_add(CSR_TAG_A, TLS_CREDENTIAL_PRIVATE_KEY,
					 test_key, sizeof(test_key));
		zassert_equal(ret, 0, "tls_credential_add should succeed for test_key");
	}

	if (keygen) {
		/* Should fail if CSR buffer is too small for keygen */
		csr_len_in = csr_len = 10;

		/* We use csr_buf_mid to avoid static memory corruption from a buffer overflow bug
		 * in mbedtls. See the `_overflow` tests for more direct verification of this bug.
		 */
		memset(csr_buf_mid, 1, csr_len);
		ret = tls_credential_csr(CSR_TAG_A, TEST_DNAME, keygen_type, csr_buf_mid, &csr_len);
		zassert_equal(ret, -EFBIG,
			"tls_credential_csr should return -EFBIG if csr buffer is too small "
			"for keygen");
		zassert_true(alleq(csr_buf_mid, csr_len_in, 0),
			"CSR buffer should be cleared after error");
		zassert_equal(csr_len, 0, "CSR buffer should be cleared after error");
	}

	/* Should fail if CSR buffer is too small for CSR */
	csr_len_in = csr_len = 140;
	memset(csr_buf, 1, csr_len);
	ret = tls_credential_csr(CSR_TAG_A, TEST_DNAME, keygen_type, csr_buf, &csr_len);
	zassert_equal(ret, -EFBIG, "tls_credential_csr should return -EFAULT if csr buffer is too "
				   "small");
	zassert_true(alleq(csr_buf, csr_len_in, 0), "CSR buffer should be cleared after error");
	zassert_equal(csr_len, 0, "CSR buffer should be cleared after error");

	if (!keygen) {
		/* Should fail if requested private key does not exist */
		csr_len_in = csr_len = sizeof(csr_buf);
		memset(csr_buf, 1, csr_len);
		ret = tls_credential_csr(CSR_TAG_B, TEST_DNAME, keygen_type, csr_buf, &csr_len);
		zassert_equal(ret, -ENOENT,
			"tls_credential_csr should return -ENOENT if requested private key "
			"does not exist");
		zassert_true(alleq(csr_buf, csr_len_in, 0),
			"CSR buffer should be cleared after error");
		zassert_equal(csr_len, 0, "CSR buffer should be cleared after error");
	}

	/* Should fail if distinguished name is invalid */
	csr_len_in = csr_len = sizeof(csr_buf);
	memset(csr_buf, 1, csr_len);
	ret = tls_credential_csr(CSR_TAG_A, "blah blah blah", keygen_type, csr_buf, &csr_len);
	zassert_equal(ret, -EFAULT, "tls_credential_csr should return -EFAULT if dname invalid");
	zassert_true(alleq(csr_buf, csr_len_in, 0), "CSR buffer should be cleared after error");
	zassert_equal(csr_len, 0, "CSR buffer should be cleared after error");

	csr_len_in = csr_len = sizeof(csr_buf);
	memset(csr_buf, 1, csr_len);
	ret = tls_credential_csr(CSR_TAG_A, "cn=us", keygen_type, csr_buf, &csr_len);
	zassert_equal(ret, -EFAULT, "tls_credential_csr should return -EFAULT if dname invalid");
	zassert_true(alleq(csr_buf, csr_len_in, 0), "CSR buffer should be cleared after error");
	zassert_equal(csr_len, 0, "CSR buffer should be cleared after error");

	csr_len_in = csr_len = sizeof(csr_buf);
	memset(csr_buf, 1, csr_len);
	ret = tls_credential_csr(CSR_TAG_A, "", keygen_type, csr_buf, &csr_len);
	zassert_equal(ret, -EFAULT, "tls_credential_csr should return -EFAULT if dname invalid");
	zassert_true(alleq(csr_buf, csr_len_in, 0), "CSR buffer should be cleared after error");
	zassert_equal(csr_len, 0, "CSR buffer should be cleared after error");

	csr_len = sizeof(csr_buf);
	ret = tls_credential_csr(CSR_TAG_A, NULL, keygen_type, csr_buf, &csr_len);
	zassert_equal(ret, -EINVAL, "tls_credential_csr should return -EINVAL if dname NULL");
	/* CSR buffer is not touched in this case since we exit early. */

	/* Verify private key is in correct state after failures. */
	pk_len_a = sizeof(pk_buf_a);
	ret = tls_credential_get(CSR_TAG_A, TLS_CREDENTIAL_PRIVATE_KEY, pk_buf_a, &pk_len_a);
	if (keygen) {
		/* Private key should not be kept after keygen CSR failures. */
		zassert_equal(ret, -ENOENT, "New private key should not be stored");
	} else {
		/* Private key should remain unchanged after existing-key CSR failures. */
		zassert_equal(ret, 0, "Existing private key should not be modified");
		zassert_equal(pk_len_a, sizeof(test_key),
			"Existing private key should not be modified");
		ret = memcmp(pk_buf_a, test_key, pk_len_a);
		zassert_equal(ret, 0, "Existing private key should not be modified");
	}

	/* Should succeed if provided valid configuration */
	csr_len = sizeof(csr_buf);
	memset(csr_buf, 0, csr_len);
	ret = tls_credential_csr(CSR_TAG_A, TEST_DNAME, keygen_type, csr_buf, &csr_len);
	zassert_equal(ret, 0, "tls_credential_csr should succeed for valid parameters");
	zassert_false(alleq(csr_buf, sizeof(csr_buf), 0),
		      "tls_credential_csr should write to csr_buf for valid parameters");
	zassert_true(csr_len > 0, "tls_credential_csr should succeed for valid parameters");

	/* CSR buffer should be valid DER CSR with correct distinguished name afterwards */
	mbedtls_x509_csr_init(&csr);
	ret = mbedtls_x509_csr_parse(&csr, csr_buf, csr_len);
	zassert_equal(ret, 0, "Resultant CSR should be valid");

	/* CSR should have the correct distinguished name */
	ret = mbedtls_x509_dn_gets(dname_buf, sizeof(dname_buf), &(csr.subject));
	zassert_true(ret > 0, "Resultant CSR should have the correct distinguished name");
	ret = strcmp(TEST_DNAME, dname_buf);
	zassert_equal(ret, 0, "Resultant CSR shuold have the correct distinguished name");

	/* Verify private key is in correct state after success. */
	pk_len_a = sizeof(pk_buf_a);
	ret = tls_credential_get(CSR_TAG_A, TLS_CREDENTIAL_PRIVATE_KEY, pk_buf_a, &pk_len_a);

	/* Private key should be kept (or stored) after CSR success. */
	zassert_equal(ret, 0, "Private key should be kept or stored");
	zassert_true(pk_len_a > 0, "Private key should be kept or stored");
	if (!keygen) {
		zassert_equal(pk_len_a, sizeof(test_key),
			"Existing private key should not be modified");
		ret = memcmp(pk_buf_a, test_key, pk_len_a);
		zassert_equal(ret, 0, "Existing private key should not be modified");
	}

	/* Stored private key should be readable by MbedTLS. */
	mbedtls_pk_init(&pk);
	ret = mbedtls_pk_parse_key(&pk, pk_buf_a, pk_len_a, NULL, 0, tls_rng, NULL);
	zassert_equal(ret, 0, "Private key should be readable by MbedTLS");

	/* Generated private key should match CSR public key */
	ret = mbedtls_pk_check_pair(&(csr.pk), &pk, tls_rng, NULL);
	zassert_equal(ret, 0, "CSR Public key should match stored private key");
	mbedtls_pk_free(&pk);
	mbedtls_x509_csr_free(&csr);

	/* Check behaviors for multiple simultaneous CSRs if keygen is enabled. */
	if (keygen) {
		/* Should fail if writing to already-occupied slot */
		csr_len = sizeof(csr_buf);
		ret = tls_credential_csr(CSR_TAG_A, TEST_DNAME, keygen_type, csr_buf, &csr_len);
		zassert_equal(ret, -EEXIST,
			"tls_credential_csr should return -EEXIST if sec tag taken");
		zassert_true(alleq(csr_buf, sizeof(csr_buf), 0),
			"CSR buffer should be cleared after error");
		zassert_equal(csr_len, 0, "CSR buffer should be cleared after error");

		/* Original private key should not be altered in this case */
		pk_len_b = sizeof(pk_buf_b);
		ret = tls_credential_get(CSR_TAG_A, TLS_CREDENTIAL_PRIVATE_KEY,
					 pk_buf_b, &pk_len_b);
		zassert_equal(ret, 0, "Original private key should not be overwritten");
		zassert_equal(pk_len_a, pk_len_b,
			      "Original private key should not be overwritten");
		ret = memcmp(pk_buf_a, pk_buf_b, pk_len_a);
		zassert_equal(ret, 0, "Original private key should not be overwritten");

		/* Additional CSRs should be generated successfully and have unique private keys */
		csr_len = sizeof(csr_buf);
		ret = tls_credential_csr(CSR_TAG_B, TEST_DNAME, keygen_type, csr_buf, &csr_len);
		zassert_equal(ret, 0, "tls_credential_csr should succeed for valid parameters");
		zassert_false(alleq(csr_buf, sizeof(csr_buf), 0),
			"tls_credential_csr should write to csr_buf for valid parameters");
		zassert_true(csr_len > 0,
			"tls_credential_csr should succeed for valid parameters");

		/* The new private key should be distinct from the first one */
		pk_len_b = sizeof(pk_buf_b);
		ret = tls_credential_get(CSR_TAG_B, TLS_CREDENTIAL_PRIVATE_KEY,
					 pk_buf_b, &pk_len_b);
		ret = memcmp(pk_buf_a, pk_buf_b, MIN(pk_len_a, pk_len_b));
		zassert_not_equal(ret, 0, "Consecutive CSRs should have distinct private keys");
	}
}

#else /* defined(CONFIG_TLS_CREDENTIAL_CSR) */

static void test_csr(enum credential_features feat)
{
	zassert_unreachable("Invalid call to test_csr. Bad test?");
}
#endif /* defined(CONFIG_TLS_CREDENTIAL_CSR) */

/* Check whether CSR or keygen (or both) with a given buffer size causes buffer overflow.
 * Returns true if overflow detected.
 */
static bool test_overflow(enum credential_features feat, size_t buf_size)
{
	size_t cred_len;
	size_t canary_margin;
	char *offset_buf;
	bool keygen =	(feat == CF_KEYGEN) || (feat == CF_KEYGEN_CSR);
	bool csr =	(feat == CF_CSR)    || (feat == CF_KEYGEN_CSR);
	enum tls_credential_keygen_type keygen_type = keygen ? TLS_CREDENTIAL_KEYGEN_DEFAULT :
							       TLS_CREDENTIAL_KEYGEN_EXISTING;


	zassert_true(keygen || csr, "Cannot test buffer overflow with neither CSR nor Keygen");

	/* Silence warnings due to tls_credential_csr possibly being an empty macro. */
	(void) keygen_type;

	/* Set up buffers. The offset creates a pre-buffer and post-buffer canary. Both
	 * types of buffer overflow are hypothetically a risk, since some mbedTLS APIs write
	 * starting from end of buffer.
	 */
	zassert_true(buf_size + 100 < sizeof(csr_buf), "Insufficient canary margin. Bad test?");
	canary_margin = (sizeof(csr_buf) - buf_size)/2;
	offset_buf = csr_buf + canary_margin;
	cred_len = buf_size;

	/* Write pattern to entire csr buffer so we can detect canary region modifications */
	memset(csr_buf, 0b1010101, sizeof(csr_buf));

	if (keygen) {
		/* Make sure slot is clear before attempting keygen. */
		clear_cred(CSR_TAG_A, TLS_CREDENTIAL_PRIVATE_KEY);
	}

	if (csr) {
		/* Perform CSR, hypothetically only writing data to the offset_buf region.  */
		(void)tls_credential_csr(CSR_TAG_A, TEST_DNAME, keygen_type, offset_buf, &cred_len);
	} else {
		/* Perform Keygen, hypothetically only writing data to the offset_buf region. */
		(void)tls_credential_keygen(CSR_TAG_A, keygen_type, offset_buf, &cred_len);
	}

	/* Ignore the write-allowed region by resetting it to the test pattern. */
	memset(offset_buf, 0b1010101, buf_size);

	/* Check for canary corruption by checking entire buffer for test pattern*/
	return !alleq(csr_buf, sizeof(csr_buf), 0b1010101);
}


ZTEST(tls_credentials, test_tls_credentials_main)
{
	/* Don't bother with main tests if we are doing a CSR/Keygen configuration edge-case
	 * test. */
	if (IS_ENABLED(CONFIG_TLS_CREDENTIAL_CSR) != IS_ENABLED(CONFIG_TLS_CREDENTIAL_KEYGEN)) {
		ztest_test_skip();
	}

	test_credential_add();
	test_credential_get();
	test_credential_internal_iterate();
	test_credential_delete();
}

/* Test that CSR+Keygen works, if both are enabled. */
ZTEST(tls_credentials, test_tls_credentials_csr_keygen)
{
	Z_TEST_SKIP_IFNDEF(CONFIG_TLS_CREDENTIAL_CSR);
	Z_TEST_SKIP_IFNDEF(CONFIG_TLS_CREDENTIAL_KEYGEN);
	test_csr(CF_KEYGEN_CSR);
}

/* Test that CSR works with existing key, if enabled. */
ZTEST(tls_credentials, test_tls_credentials_csr_preexisting)
{
	Z_TEST_SKIP_IFNDEF(CONFIG_TLS_CREDENTIAL_CSR);
	test_csr(CF_CSR);
}

/* Test for CSR buffer overflow (pre-existing)*/
ZTEST(tls_credentials, test_tls_credentials_csr_preexisting_overflow)
{
	int ret;

	Z_TEST_SKIP_IFNDEF(CONFIG_TLS_CREDENTIAL_CSR);

	/* Set up private key */
	ret = tls_credential_add(CSR_TAG_A, TLS_CREDENTIAL_PRIVATE_KEY, test_key, sizeof(test_key));
	zassert_equal(ret, 0, "tls_credential_add should succeed for test_key");

	/* Test with valid CSR buffer size. */
	zassert_false(test_overflow(CF_CSR, 250),
		"tls_credential_csr should not write outside specified buffer region");

	/* Test with buffer size too small for CSR. */
	zassert_false(test_overflow(CF_CSR, 100),
		"tls_credential_csr should not write outside specified buffer region");
}

/* Test for CSR buffer overflow (keygen)*/
ZTEST(tls_credentials, test_tls_credentials_csr_keygen_overflow)
{
	Z_TEST_SKIP_IFNDEF(CONFIG_TLS_CREDENTIAL_CSR);
	Z_TEST_SKIP_IFNDEF(CONFIG_TLS_CREDENTIAL_KEYGEN);

	/* Test with valid CSR buffer size. */
	zassert_false(test_overflow(CF_KEYGEN_CSR, 250),
		"tls_credential_csr should not write outside specified buffer region");

	/* Test with buffer size too small for CSR. */
	zassert_false(test_overflow(CF_KEYGEN_CSR, 140),
		"tls_credential_csr should not write outside specified buffer region");

	/* Test with buffer size too small for keygen.
	 * NOTE: mbedtls currently has a buffer overflow bug which gets triggered by this test.
	 *	 Switch back to zassert_false once that bug is removed.
	 */
	zassert_true(test_overflow(CF_KEYGEN_CSR, 10),
		"CSR no longer overflows for small buffer size. Was the MbedTLS bug patched? "
		"If so please update this test suite");
}

/* Test for Keygen buffer overflow */
ZTEST(tls_credentials, test_tls_credentials_keygen_overflow)
{
	Z_TEST_SKIP_IFNDEF(CONFIG_TLS_CREDENTIAL_KEYGEN);

	/* Test with valid keygen buffer size. */
	zassert_false(test_overflow(CF_KEYGEN, 140),
		"tls_credential_csr should not write outside specified buffer region");

	/* Test with buffer size too small for keygen.
	 * NOTE: mbedtls currently has a buffer overflow bug which gets triggered by this test.
	 *	 Switch back to zassert_false once that bug is removed.
	 */
	zassert_true(test_overflow(CF_KEYGEN, 10),
		"Keygen no longer overflows for small buffer size. Was the MbedTLS bug patched? "
		"If so please update this test suite");
}

/* Test that CSR fails if disabled. */
ZTEST(tls_credentials, test_tls_credentials_csr_disabled)
{
	int ret;
	size_t csr_len = sizeof(csr_buf);

	Z_TEST_SKIP_IFDEF(CONFIG_TLS_CREDENTIAL_CSR);

	/* Silence warnings due to tls_credential_csr possibly being an empty macro. */
	(void) csr_len;

	/* The choice of keygen type really doesn't matter, but we pick
	 * TLS_CREDENTIAL_KEYGEN_EXISTING to hypothetically prevent a false positive if
	 * keygen is disabled. This is technically invalid since we have not set up a pre-existing
	 * key, but if tls_credential_csr somehow executes, then in that situation it still won't
	 * return -ENOTSUP, so we don't care.
	 */
	ret = tls_credential_csr(CSR_TAG_A, "CN=US", TLS_CREDENTIAL_KEYGEN_EXISTING, csr_buf,
				 &csr_len);

	/* Should fail if not enabled */
	zassert_equal(ret, -ENOTSUP);
}

/* Test that CSR+Keygen fails if keygen disabled while CSR is enabled. */
ZTEST(tls_credentials, test_tls_credentials_csr_keygen_disabled)
{
	int ret;
	size_t csr_len = sizeof(csr_buf);

	Z_TEST_SKIP_IFNDEF(CONFIG_TLS_CREDENTIAL_CSR);
	Z_TEST_SKIP_IFDEF(CONFIG_TLS_CREDENTIAL_KEYGEN);

	/* Silence warnings due to tls_credential_csr possibly being an empty macro. */
	(void) csr_len;

	ret = tls_credential_csr(CSR_TAG_A, "CN=US", TLS_CREDENTIAL_KEYGEN_DEFAULT, csr_buf,
				 &csr_len);

	/* Should fail if keygen is not enabled */
	zassert_equal(ret, -ENOTSUP);
}

/* Test that Keygen fails if disabled. */
ZTEST(tls_credentials, test_tls_credentials_keygen_disabled)
{
	int ret;
	size_t key_len = sizeof(pk_buf_a);

	Z_TEST_SKIP_IFDEF(CONFIG_TLS_CREDENTIAL_KEYGEN);

	/* Silence warnings due to tls_credential_keygen possibly being an empty macro. */
	(void) key_len;

	ret = tls_credential_keygen(CSR_TAG_A, TLS_CREDENTIAL_KEYGEN_DEFAULT, pk_buf_a, &key_len);

	/* Should fail if keygen is not enabled */
	zassert_equal(ret, -ENOTSUP);
}

/* Test that Keygen fails if given invalid inputs. */
ZTEST(tls_credentials, test_tls_credentials_keygen_invalid)
{
	int ret;
	size_t pk_len;
	size_t pk_len_in;
	char *pk_buf_mid = pk_buf_a + 100;

	Z_TEST_SKIP_IFNDEF(CONFIG_TLS_CREDENTIAL_KEYGEN);

	/* Silence warnings due to tls_credential_keygen possibly being an empty macro. */
	(void) pk_len;

	/* Keygen should fail if key buffer too small.
	 * We use csr_buf_mid to work around static memory corruption from a buffer overflow bug
	 * in mbedtls. See the `_overflow` tests for more direct verification of this bug.
	 */
	pk_len_in = pk_len = 10;
	memset(pk_buf_mid, 1, pk_len);
	ret = tls_credential_keygen(CSR_TAG_A, TLS_CREDENTIAL_KEYGEN_DEFAULT, pk_buf_mid, &pk_len);
	zassert_equal(ret, -EFBIG,
		"tls_credential_keygen should return -EFBIG if key buffer is too small");
	zassert_true(alleq(pk_buf_mid, pk_len_in, 0), "Key buffer should be cleared after error");
	zassert_equal(pk_len, 0, "Key buffer should be cleared after error");

	/* Keygen should fail if invalid keygen type provided. */
	pk_len = sizeof(pk_buf_a);
	memset(pk_buf_a, 1, pk_len);
	ret = tls_credential_keygen(CSR_TAG_A, TLS_CREDENTIAL_KEYGEN_EXISTING, pk_buf_a, &pk_len);
	zassert_equal(ret, -ENOTSUP,
		"tls_credential_keygen should return -ENOTSUP if invalid keygen type used");
	zassert_true(alleq(pk_buf_a, sizeof(pk_buf_a), 0),
		"Key buffer should be cleared after error");
	zassert_equal(pk_len, 0, "Key buffer should be cleared after error");


	/* Keygen should fail if invalid key buffer provided. */
	pk_len = sizeof(pk_buf_a);
	ret = tls_credential_keygen(CSR_TAG_A, TLS_CREDENTIAL_KEYGEN_EXISTING, NULL, &pk_len);
	zassert_equal(ret, -EINVAL,
		"tls_credential_keygen should return -EINVAL if invalid key buffer used");

	/* Keygen should fail if invalid key length provided. */
	ret = tls_credential_keygen(CSR_TAG_A, TLS_CREDENTIAL_KEYGEN_EXISTING, pk_buf_a, NULL);
	zassert_equal(ret, -EINVAL,
		"tls_credential_keygen should return -EINVAL if invalid key length provided");

	/* Fill CSR_TAG_A. */
	ret = tls_credential_add(CSR_TAG_A, TLS_CREDENTIAL_PRIVATE_KEY, test_key, sizeof(test_key));
	zassert_equal(ret, 0, "tls_credential_add should succeed for test_key");

	/* Keygen should fail if filled sectag selected. */
	pk_len = sizeof(pk_buf_a);
	memset(pk_buf_a, 1, pk_len);
	ret = tls_credential_keygen(CSR_TAG_A, TLS_CREDENTIAL_KEYGEN_DEFAULT, pk_buf_a, &pk_len);
	zassert_equal(ret, -EEXIST,
		"tls_credential_keygen should return -EEXIST if a key already exists at "
		"the requested sectag");
	zassert_true(alleq(pk_buf_a, sizeof(pk_buf_a), 0),
		"Key buffer should be cleared after error");
	zassert_equal(pk_len, 0, "Key buffer should be cleared after error");
}

/* Test that Keygen succeeds if enabled.
 * Validity testing of keygen routine is (mostly) handled during csr_keygen tests.
 * CSR is a good way to test the validity of output private keys, after all.
 *
 * The exception to this is validation of the public key output, which is not used by CSR.
 */
ZTEST(tls_credentials, test_tls_credentials_keygen)
{
	int ret;
	size_t pk_len_a = sizeof(pk_buf_a);
	size_t pk_len_b = sizeof(pk_buf_b);

	Z_TEST_SKIP_IFNDEF(CONFIG_TLS_CREDENTIAL_KEYGEN);

	/* Silence warnings due to tls_credential_keygen possibly being an empty macro. */
	(void) pk_len_a;
	ret = tls_credential_keygen(CSR_TAG_A, TLS_CREDENTIAL_KEYGEN_DEFAULT, pk_buf_a, &pk_len_a);

	/* Should succeed if keygen is enabled */
	zassert_equal(ret, 0);

	/* Private key should be stored after keygen success */
	ret = tls_credential_get(CSR_TAG_A, TLS_CREDENTIAL_PRIVATE_KEY, pk_buf_b, &pk_len_b);
	zassert_equal(ret, 0, "Keygen should write private key to target sectag");
	zassert_true(pk_len_b > 0, "Keygen should write private key to target sectag");

	zassert_true(validate_keypair(pk_buf_b, pk_len_b, pk_buf_a, pk_len_a),
		"Keygen should generate matching public and private key pairs");
}

static void tls_cred_test_cleanup(void *data)
{
	ARG_UNUSED(data);

	int i;
	for (i = 0; i <= CONFIG_TLS_MAX_CREDENTIALS_NUMBER; i++) {
		/* This may seem excessive, but it is fast if the slot is already empty. */
		clear_cred(i, TLS_CREDENTIAL_CA_CERTIFICATE);
		clear_cred(i, TLS_CREDENTIAL_SERVER_CERTIFICATE);
		clear_cred(i, TLS_CREDENTIAL_PRIVATE_KEY);
		clear_cred(i, TLS_CREDENTIAL_PSK);
		clear_cred(i, TLS_CREDENTIAL_PSK_ID);
	}
}

ZTEST_SUITE(tls_credentials, NULL, NULL, tls_cred_test_cleanup, NULL, NULL);
